---
title: gRPCity
description: gPRCity is a simple, easy-to-use, and advanced gRPC microservice library based on Node.js.
---

import LogoImage from '@components/logoImage'

<LogoImage />

# gRPCity

<p className="_flex _h-6 _mt-4 _gap-2">
    <a href="https://github.com/chakhsu/grpcity" target="_blank">
        <img alt="build-status" src="https://github.com/chakhsu/grpcity/actions/workflows/build.yml/badge.svg" loading="lazy" decoding="async"></img>
    </a>
    <a href="https://www.npmjs.com/package/grpcity" target="_blank">
        <img alt="npm" src="https://img.shields.io/npm/v/grpcity" loading="lazy" decoding="async"></img>
    </a>
    <a href="https://github.com/chakhsu/grpcity/blob/main/LICENSE" target="_blank">
        <img alt="license" src="https://img.shields.io/npm/l/grpcity" loading="lazy" decoding="async"></img>
    </a>
</p>

gPRCity: A simple, easy-to-use, and advanced gRPC microservice library based on Node.js.

### What is it?

`gRPCity` is a gRPC microservice library running on Node.js.
It combines `proto-loader` and `grpc-js`, simplifying many difficult technical concepts and steps,
providing an easy-to-understand and concise API to complete the loading of proto files,
and also provides complete and powerful client and server support. Of course,
there are also many advanced features to meet most development scenarios.

It mainly solves three problems: how to load proto files, how clients can better initiate calls and how servers can better provide support.
In `gRPCity`, good answers are given to all these questions,
and `gRPCity` also provides good support in the face of more complex business scenarios.

> The name comes from: gRPC + City = gRPCity,
which embodies the author's hope that this library can support the construction of the business city,
from the perspective of the technical base, allowing everyone to focus on the business and better support delivery.

### Why?

As the business grows, traffic and data will continue to expand,
and the fine utilization of resources will become increasingly important.
At this time, microservices is a way that can help us solve how to make full use of hardware resources,
and also need to meet the needs of code reuse to adapt to business under different scenarios.
In this context, this library was created. Of course, the decision to open source is mainly because we have done a lot of microservice practices with Node.js,
so we hope to let everyone see what we are doing through open source.

The first line of code for `gRPCity` was written on October 28, 2019, and [Kamuel](https://github.com/k7) contributed the `proto load` and `client proxy` capabilities.
It was then continued by [Chakhsu](https://github.com/chakhsu), who added `multi proto load`, `full client proxy`, `server call proxy` and `full stream support`,
making the library gradually complete. The library is now in production, with hundreds of instances using it. Everyone is welcome to try it.

### Design

The internal data flow design of `gRPCity` is very clear, as shown below:

`.proto` -> `this._packagePrefix` -> `this._types`:
![gPRCity loader](/img/grpcity-loader.svg)

`init clients` -> `get client` -> `client proxy` -> `rpc method call` -> `do`:
![gPRCity client](/img/grpcity-client.svg)

`init server` -> `instance` -> `call proxy`:
![gPRCity server](/img/grpcity-server.svg)

### Features

- **API**: Communication protocol is based on gRPC and defined through Protobuf.
- **Protobuf**: Supports only dynamic load, simplifying the loading process of protobuf files.
- **Client**: Configured once, callable anytime, anywhere, and supports multi-server invocation.
- **Server**: Simplifies the initialization process with a three-step start, supporting multi-server deployment.
- **Credentials**: Complete support for certificate loading on both the client and server.
- **No-Route**: No routing, RPC is inherently bound to methods.
- **Middleware**: Both client and server support middleware.
- **Metadata**: Standardizes the transmission and retrieval of metadata.
- **Reflection**: Built-in gRPC Reflection API in server.
- **Error**: Provides dedicated Error objects to ensure targeted handling of
  exceptions after catching.
- **Promise**: Supports promisify internally in RPC methods while also
  preserving callbackify.
- **Config**: Supports protobuf load configurations and gRPC channel configurations.
- **Typescript**: Implemented purely in TypeScript with comprehensive types.

...and a lot more.

### License

Released under the MIT License.
