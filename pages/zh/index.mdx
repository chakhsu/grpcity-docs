---
title: gRPCity
description: gPRCity 是一套简单、易用和高级的基于 Node.js 的 gRPC 微服务库。
---

# gRPCity

<p className="_flex _h-6 _mt-4 _gap-2">
    <img alt="build-status" src="https://github.com/chakhsu/grpcity/actions/workflows/tests.yml/badge.svg" loading="lazy" decoding="async"></img>
    <img alt="npm" src="https://img.shields.io/npm/v/grpcity" loading="lazy" decoding="async"></img>
    <img alt="license" src="https://img.shields.io/npm/l/grpcity" loading="lazy" decoding="async"></img>
    <img alt="code-style" src="https://img.shields.io/badge/code_style-standard-brightgreen.svg" loading="lazy" decoding="async"></img>
</p>

gPRCity: 一套简单、易用和高级的基于 Node.js 的 gRPC 微服务库。

### 是什么？

`gRPCity` 是一个运行在 Node.js 的 gRPC 微服务库，结合了 `proto-loader` 和 `grpc-js`，提供了非常简易的方式去加载 proto 文件，简化了很多难以理解的技术概念，只需要几个函数就可以轻松实现客户端和服务端，同时也提供非常多高级的功能满足大多数开发场景。

> 名字来源于: gRPC + City = gRPCity，寄托了作者希望这个库能支撑了业务城市的建设，以技术底座的视角，让大家聚焦业务，更好地支撑交付。

### 起源

`gRPCity` 的第一行代码最早写在2019年10月28日，并由 [Kamuel](https://github.com/k7) 贡献了 `proto load` 和 `client proxy` 能力，这部分的代码版本为`0.5`。
`0.5`版本之后，[Chakhsu](https://github.com/chakhsu) 继续完善功能，逐步支持了`multi proto load`、`full client proxy`、`server call proxy` 和 `full stream support`，使得该库功能逐渐齐全。
目前该库已投入到生产中，使用该库的实例数有上百个。欢迎各位试用。

### 仓库

- GitHub: https://github.com/chakhsu/grpcity
- npm: https://www.npmjs.com/package/grpcity

### 设计

`gRPCity` 内在执行设计是非常清晰的，如下所示。

`.proto` -> `this._packagePrefix` -> `this._types`:
![gPRCity loader](/img/grpcity-loader.svg)

`init clients` -> `get clinet` -> `client proxy` -> `rpc method call` -> `do`:
![gPRCity client](/img/grpcity-client.svg)

`init server` -> `instance` -> `call proxy`:
![gPRCity server](/img/grpcity-server.svg)

### 原则

- **聚焦**: 只做好 gRPC 微服务库，不做大而全的框架；
- **简单**: 提供简单和清晰的 API，轻松看懂，快速上手；
- **易用**: 尽可能地简化复杂的概念，提供清晰的、容易的代码；
- **稳定**: 可测试性高，覆盖率高，有线上实践安全可靠；
- **共建**: 充分利用 Node.js 社区和生态；

### 特性

- **API**: 通信协议以 gRPC 为基础，通过 Protobuf 进行定义；
- **Protobuf**: 只支持动态 pb 加载，简化了 pb 文件的加载流程；
- **Client**: 一次配置，随时随处调用，支持 multi-server 的调用；
- **Server**: 简化了初始化流程，三步完成服务端的启动，支持 multi-server 的启动；
- **No-Route**: 无路由，rpc 与 method 天生绑定；
- **Middleware**: 集成了跟 Koa 一样中间件机制，得到了 rpc 前后处理的能力；
- **Metadata**: 规范化了元信息的传递和获取；
- **Error**: 提供了专有 Error 对象，保证异常捕捉后可以针对性处理；
- **Promise**: rpc 方法内部支持了 promisify，同时也保留了 callbackify ；
- **Config**: 与官方配置对齐，支持 pb load 配置和 gRPC channel 配置；
- **Pattern**: 单例模式，保证了实例对象的唯一性；
- **Typescript**: 支持，保证了 ts 和 js 的兼容性；

...还有更多等你发现。

### License

Released under the MIT License.