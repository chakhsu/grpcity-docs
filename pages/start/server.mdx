import { Card, Cards } from 'nextra/components'

# Server Side

[上一篇教程](/start/proto-loader)，我们得到了`loader.js`，一个已经帮我们完成了 proto 文件加载工作的模块，在这篇教程里，我们将会使用该模块完成服务端的开发。我们开始吧~

我们将会提供两种写法给你，以满足不同的场景需要。

### 项目目录

```sh
.
├── loader.js
├── package-lock.json
├── package.json
├── proto
│   └── test
│       └── helloworld
│           ├── model
│           │   └── message.proto
│           └── service.proto
├── server.js
└── server2.js
```

我们在原来的项目的提前创建好`server.js`和`server2.js`，分别对应两种写法。

### 写法1 (推荐)

第一步：导入`loader.js`模块，我们在后续的开发中使用到这个模块去完成rpc与服务端的方法进行绑定。

```js filename="./server.js"
import loader from "./loader.js"
```

#### 定义类

第二步：定义`Greeter`类

```js filename="./server.js"
class Greeter {
    // 在创建类时需要传入loader
    constructor(loader) {
        this._loader = loader
        this.count = 0
    }

    // 类执行初始化：将本类的方法与指定的 service 绑定
    init(server) {
        server.addService(
            // 指定 service name
            this._loader.service("test.helloworld.Greeter"),
            // 指定 rpc method 位置，并进行 callback 处理，同时排除本类中的 init 方法
            this._loader.callbackify(this, { exclude: ["init"] })
        )
    }

    // rpc method
    async sayGreet(ctx) {
        const { name } = ctx.request
        this.count++
        return {
            message: `hello ${name || "world"} by Greeter`,
            count: this.count
        }
    }
}
```

第三步：继续用同样的方式定义`Hellor`类

```js filename="./server.js"
class Hellor {
    // 在创建类时需要传入loader
    constructor(loader) {
        this._loader = loader
    }

    // 类执行初始化：将本类的方法与指定的 service 绑定
    init(server) {
        server.addService(
            // 指定 service name
            this._loader.service("test.helloworld.Hellor"),
            // 指定 rpc method 位置，并进行 callback 处理，同时排除本类中的 init 方法
            this._loader.callbackify(this, { exclude: ["init"] })
        )
    }

    // rpc method
    async sayHello(ctx) {
        const { name } = ctx.request
        return { message: `hello ${name || "world"} by Hellor` }
    }
}
```

#### 绑定和启动

```js filename="./server.js"
const start = async (addr) => {
    // loader 初始化
    await loader.init()

    // server 初始化并获取实例
    const server = loader.initServer()
    // 多个 service 类创建
    const servicers = [new Greeter(loader), new Hellor(loader)]
    // 多个 service 初始化：rpc 与类方法绑定
    await Promise.all(servicers.map(async s => s.init(server)))

    // 启动
    await server.listen(addr)
    console.log('gRPC Server is started: ', addr)
}

// 执行
start('127.0.0.1:9098')
```

### 写法2

我们另外在`server2.js`上进行编码。

第一步：导入`loader.js`模块，我们在后续的开发中使用到这个模块去完成rpc与服务端的方法进行绑定。

```js filename="./server2.js"
import loader from "./loader.js"
```

#### 定义对象

第二步：定义`Greeter`对象

```js filename="./server2.js"
let count = 0
const Greeter = {
    // rpc method
    sayGreet: async (ctx) => {
        const { name } = ctx.request
        count++
        return {
            message: `hello ${name || "world"} by Greeter`,
            count
        }
    }
}
```

第三步：继续用同样的方式定义`Hellor`对象

```js filename="./server2.js"
const Hellor = {
    // rpc method
    sayHello: async (ctx) => {
        const { name } = ctx.request
        return { 
            message: `hello ${name || "world"} by Hellor` 
        }
    }
}
```

#### 绑定和启动


```js filename="./server2.js"
const start = async (addr) => {
    // loader 初始化
    await loader.init()

    // server 初始化并获取实例
    const server = loader.initServer()

    // service rpc 与 对象方法绑定
    server.addService(loader.service('test.helloworld.Greeter'), loader.callbackify(Greeter))
    server.addService(loader.service('test.helloworld.Hellor'), loader.callbackify(Hellor))

    // 启动
    await server.listen(addr)
    console.log('gRPC Server is started: ', addr)
}

// 执行
start('127.0.0.1:9099')
```

### 联调

我们看到，不管是方法1还是方法2，都将多个 service 注册到了同一个 server 里。
这里为啥推荐方法1，是因为方法1的写法对模块化的学法更友好，可以将类拆出来，独立成文件，实现启动流程与业务解耦，增加服务的扩展性。

我们将会启动这两个 server，在后续 client side 教程中，我们将会同时调用这两个 server，将 gRPC 的调用闭环。详细的联调环节将会在 client side 教程中展示。

---

下面我们就开始后续的客户端上手开发工作吧。

<Cards>
    <Card
        title="Proto Loader →"
        href="/start/proto-loader"
    />
    <Card
        title="Client Side →"
        href="/start/client"
    />
</Cards>
