{"/en-US/apis":{"title":"API","data":{"":"Below, we will showcase all the APIs provided for production development of gRPCity to developers. The API will be divided into three parts, namely loader, server, and client."}},"/en-US/guide":{"title":"User Guide","data":{"":"Please select one of the following guides for a deeper understanding and learning:"}},"/en-US/apis/server":{"title":"Server API","data":{"":"To obtain a server instance, call loader.initServer(), which provides a set of APIs to facilitate gRPC Server development.","addservice#addService()":"Description:\nBinds the proto service rpc definition to a specific execution implementation.\nParameters:\nservice: (required) The service specified in the proto, obtained through loader.service(name);\nimplementation: (required) An object or class with the methods defined by the service rpc, which needs to be made async using loader.callbackify() and supports middleware.\nReturn Value:\nvoid: No return value.","removeservice#removeService()":"Description:\nUnbinds a previously bound service.\nParameters:\nservice: (required) The service specified in the proto, obtained through loader.service(name).\nReturn Value:\nvoid: No return value.","makeservercredentials#makeServerCredentials()":"Description:\n1\nParameters:\nrootCerts: (optional) Buffer, typically the CA file;\nkeyCertPairs: Certificate pairs, key and crt, must be an array;\nprivate_key: (optional) Buffer, typically the key file;\ncert_chain: (optional) Buffer, typically the crt file;\ncheckClientCertificate: (optional) Whether to check the client certificate;\nReturn Value:There are two scenarios:\nIf all parameters are provided, it returns:grpc.ServerCredentials.createSsl();\nIf no parameters are provided, it returns: grpc.ServerCredentials.createInsecure().","addmiddleware#addMiddleware()":"Description:\nAdds middleware to handle logic before and after the RPC.\nParameters:\nfn: (required) Middleware function, typically an async (ctx, next) => { await next() }.\nReturn Value:\nvoid: No return value.","addmiddlewares#addMiddlewares()":"Description:\nAdds multiple middlewares to handle logic before and after the RPC.\nParameters:\nfns: (required) Array of middleware functions, typically [async (ctx, next) => { await next() }].\nReturn Value:\nvoid: No return value.","listen#listen()":"Description:\nListens on an address and port to start the gRPC service.\nParameters:\naddr: (required) The address and port to listen to for service startup. Supported types include:\nstring: in the format of ip+port, like 127.0.0.1:9099;\nobject: { host, port };\nhost: a string that supports both IP and domain names;\nport: a number, with a minimum value of 0 and a maximum value of 65535;\ncredentials: (optional) Generated using makeServerCredentials and passed to the listen call;\nReturn Value:\nvoid: No return value.","shutdown#shutdown()":"Description:\nGracefully shuts down the gRPC service.\nParameters:\nvoid: No parameters.\nReturn Value:\nvoid: No return value.","forceshutdown#forceShutdown()":"Description:\nForcefully shuts down the gRPC service.\nParameters:\nvoid: No parameters.\nReturn Value:\nvoid: No return value."}},"/en-US/apis/grpcloader":{"title":"gRPC Loader API","data":{"class-grpcloader#class GrpcLoader":"Parameter Description:\narray: [ { location, files } ], supports an array of objects;\nsingle: { location, files }, supports a single object;\nWhere { location, files } indicates:\nlocation: (required) path string, e.g., path.join(__dirname, './proto');\nfiles: (required) array of strings, e.g., ['path/to/service-a.proto', 'path/to/service-b.proto']\nReturn Value:\nReturns an instantiated GrpcLoader instance, containing a series of internal variables, methods, and external methods.\nThe following will display the APIs in GrpcLoader","init#init()":"Description:\nInitializes and can initialize all clients, binds service proto definitions to server addresses, and supports environment configuration.\nParameters:\nservices: (any one) similar to the parameters in initClient(), if this parameter is provided, you can skip initClient and directly complete client initialization. Supports both string and object parameters;\nstring: (any one) in the format of ip+port, like 127.0.0.1:9099;\nobject: (any one) { host, port };\nhost: a string that supports both IP and domain names;\nport: a number, with a minimum value of 0 and a maximum value of 65535;\nisDev: (optional) boolean, whether it is in development mode;\npackagePrefix: (optional) string, service name package prefix, e.g., dev, stage, etc.;\nloadOptions: (optional) proto load options;\nchannelOptions: (optional) proto channel options;\nappName: (optional) string, the name of the current application for labeling;\nReturn Value:\nvoid: No return value.","initclients#initClients()":"Description:\nInitializes all clients, binds service proto definitions to server addresses.\nParameters:\nservices: (any one) similar to the parameters in initClient(), if this parameter is provided, you can skip initClient and directly complete client initialization. Supports both string and object parameters;\nstring: (any one) in the format of ip+port, like 127.0.0.1:9099;\nobject: (any one) { host, port };\nhost: a string that supports both IP and domain names;\nport: a number, with a minimum value of 0 and a maximum value of 65535;\nchannelOptions: (optional) proto channel options;\ncredentials: (optional) certificate chain, obtained using makeCredentials();\nReturn Value:\nvoid: No return value.","client#client()":"Description:\nObtains a client instance corresponding to 'path.to.serviceName' defined in the proto, using proxy, caches the client instance, and you can see more usage APIs in Client Proxy.\nParameters:\nname: (required) proto-defined service, package path + service name;\nhost: (optional) a string that supports both IP and domain names;\nport: (optional) a number, with a minimum value of 0 and a maximum value of 65535;\ntimeout: (optional) a number, in milliseconds, to control the timeout of RPC calls;\ncredentials: (optional) certificate chain, obtained using makeCredentials();\nchannelOptions: (optional) proto channel options;\nReturn Value:\nvoid: No return value.","clientwithoutcache#clientWithoutCache()":"Description:\nObtains a client instance corresponding to 'path.to.serviceName' defined in the proto, using proxy, does not cache, and you can see more usage APIs in Client Proxy.\nParameters:\nname: (required) proto-defined service, package path + service name;\nhost: (optional) a string that supports both IP and domain names;\nport: (optional) a number, with a minimum value of 0 and a maximum value of 65535;\ntimeout: (optional) a number, in milliseconds, to control the timeout of RPC calls;\ncredentials: (optional) certificate chain, obtained using makeCredentials();\nchannelOptions: (optional) proto channel options;\nReturn Value:\nvoid: No return value.","realclient#realClient()":"Description:\nObtains a client instance corresponding to 'path.to.serviceName' defined in the proto, does not use proxy, does not cache, and returns an unprocessed client instance.\nParameters:\nname: (required) proto-defined service, package path + service name;\nhost: (optional) a string that supports both IP and domain names;\nport: (optional) a number, with a minimum value of 0 and a maximum value of 65535;\ntimeout: (optional) a number, in milliseconds, to control the timeout of RPC calls;\ncredentials: (optional) certificate chain, obtained using makeCredentials();\nchannelOptions: (optional) proto channel options;\nReturn Value:\nvoid: No return value.","makecredentials#makeCredentials()":"Description:\nCreates certificates for client use.\nParameters:\nrootCerts: (optional) Buffer, typically the CA file;\nprivateKey: (optional) Buffer, typically the key file;\ncertChain: (optional) Buffer, typically the crt file;\nverifyOptions: (optional), { checkServerIdentity };\ncheckServerIdentity: callback function, (hostname, cert) => { };\nReturn Value:There are two scenarios:\nIf all parameters are provided, it returns:grpc.credentials.createSsl();\nIf no parameters are provided, it returns: grpc.credentials.createInsecure().","makemetadata#makeMetadata()":"Description:\nCreates metadata instances for client use.\nParameters:\nobject: (required), an object:\n[key]: a string, the key value;\n[value]: a string, or a string array, non-string situations will be converted to\nBuffer internally;Return Value:\nMetadata instance.","initserver#initServer()":"Description:\nCreates a gRPC server instance and provides a series of server APIs. For more related APIs, please refer to Server.\nParameters:\nchannelOptions: (optional) proto channel options;\nReturn Value:\nReturns a Server instance, for more APIs, please refer to Server.","callbackify#callbackify()":"Description:\nMainly used with server.addService(), it converts async func to callback func for binding service rpc to target.\nParameters:\ntarget: (required) an object or instance containing the rpc func itself.\nobject: (optional) an object:\nexclude: (optional) an array of strings, excluding methods in target that do not need to participate in service rpc binding;\ninherit: (optional) if target is obtained through inheritance and the inherited methods should also be bound to service rpc, the inherited object needs to be passed as well;\nReturn Value:\nA callbackify methods object that can be used with server.addService(), without error.","service#service()":"Description:\nGets the service definition in the proto.\nParameters:\nname: (required) specifies the routing of the proto file, which is the location of the service;\nReturn Value:\nThe service definition in the proto.","type#type()":"Description:\nGets the type definition in the proto;\nIncludes the ability to use service().\nParameters:\nname: (required) specifies the routing of the proto file, from the package to the service, model, or message;\nReturn Value:\nThe type definition in the proto.","message#message()":"Description:\nGets the message definition in the proto;\nParameters:\nname: (required) specifies the routing of the proto file, which is the name of the message chain in the routing.\nReturn Value:\nThe message definition in the proto."}},"/en-US/guide/client":{"title":"Client","data":{"":"The Client is one of the core features of gRPCity, primarily responsible for obtaining services and making RPC calls.","initialization#Initialization":"There are two ways to initialize the client: init() and initClients(). These two methods have specific use cases:\ninit(): Supports the services and channelOptions parameters, which automatically create the client internally, bind the service to RPC, but do not support certificates.\ninitClients(): Supports the services, channelOptions, and credentials parameters, allowing certificate support.\ninit() is more suitable if you want to initialize the client in a unified location and avoid complexity in other calls. On the other hand, initClients() is suitable for fine-grained control, such as handling servers with and without certificates or making fewer calls in specific locations.Both methods can coexist, but you need to execute init() before using initClients.For an explanation of the channelOptions parameter, please refer to the Config Guide. Here are some examples:\nOr","getting-instances#Getting Instances":"Obtaining instances is relatively straightforward; you can simply call client() and provide the complete service name, including the package name.\nNote: client() caches the client, ensuring that when you retrieve the same client multiple times, it does not create redundant instances, reducing memory consumption.","making-rpc-calls#Making RPC Calls":"There are two methods for making RPC calls: async and callback. Typically, we use the async syntax, which supports promises.","async#async":"Here, we use the async/await syntax directly.\nrpcMethod (Request Method): This is the method to execute the request. The request method depends on the rpc defined in the .proto file of the gRPC service, which comes in four forms: unary, server-streaming, client-streaming, and bidirectional-streaming.\nrequest (Request Parameters): This is an object containing the request data. The structure of the request object depends on the message type defined in the .proto file of the gRPC service.\nmetadata (Metadata): This is an optional parameter used to pass metadata related to the request. Metadata is represented as key-value pairs and can include data for authentication, authorization, tracing, or other purposes.\noptions (Options): This is an optional parameter used to set specific call options. It's an object containing a set of key-value pairs that configure the behavior of the call. Some available options include timeout, retry strategies, and more. If not provided, a default 10-second timeout is set, which can be modified by passing a deadline parameter.\nThe example shown here is for unary calls:\nAfter making the request, the client will receive a result containing three values: status, metadata, and response.\nstatus: The status after the server has processed the request.\nmetadata: Metadata information returned by the server.\nresponse: The result after the server has completed processing.\nLet's print the returned result:","callback#callback":"For callback calls, you need to include the .call. prototype chain.\nThe callback method provides the capability to handle events in a streaming fashion.For more information on using streams, please refer to the Stream and Stream v2 guides."}},"/en-US/apis/client-proxy":{"title":"Client Proxy","data":{"proxymethod#proxy[method]":"","unary#unary":"Description:\nPerform a rpcUnaryMethod call, point-to-point, and wait for the result to be returned.\nParameters:\nrequest (Request Data): This is an object containing the request data. The structure of the request object depends on the message type defined in the .proto file of the gRPC service.\nmetadata (Metadata): This is an optional parameter used to pass metadata related to the request. Metadata is represented as key-value pairs and can contain data for purposes like authentication, authorization, tracking, or others.\noptions (Options): This is an optional parameter used to set specific call options. It's an object containing a set of key-value pairs that can be used to configure the call's behavior. Some available options include timeout duration, retry strategy, and more. If not provided, a default 10-second timeout will be set, and you can modify the timeout duration by passing deadline or timeout as options.\nReturn Value:\nobject: { status, metadata, response }\nstatus: The status after server-side processing.\nmetadata: Metadata information returned by the server.\nresponse: The result after server-side processing.","client-stream#client stream":"Description:\nHandle a rpcClientStreamMethod call, providing the client with the ability to send a stream of information and receive the result after server-side processing.\nParameters:\nmetadata (Metadata): This is an optional parameter used to pass metadata related to the request. Metadata is represented as key-value pairs and can contain data for purposes like authentication, authorization, tracking, or others.\noptions (Options): This is an optional parameter used to set specific call options. It's an object containing a set of key-value pairs that can be used to configure the call's behavior. Some available options include timeout duration, retry strategy, and more. If not provided, a default 10-second timeout will be set, and you can modify the timeout duration by passing deadline or timeout as options.\nReturn Value:\nStream instance providing a series of methods to handle client-side streaming.","write#write()":"Description:\nThe client sends a stream of data.\nParameters:\nrequest (Request Data): This is an object containing the request data. The structure of the request object depends on the message type defined in the .proto file of the gRPC service.\nReturn Value:\nBoolean: Boolean value, typically true.","writeall#writeAll()":"Description:\nThe client sends multiple data entries in bulk.\nParameters:\nrequest (Request Data): This is an object containing the request data. The structure of the request object depends on the message type defined in the .proto file of the gRPC service.\nReturn Value:\nvoid: No return value.","writeend#writeEnd()":"Description:\nGet the result after server-side processing of the stream.\nParameters:\nvoid: No parameters.\nReturn Value:\nobject: { status, metadata, response }\nstatus: The status after server-side processing.\nmetadata: Metadata information returned by the server.\nresponse: The result after server-side processing.","server-stream#server stream":"Description:\nHandle a rpcServerStreamMethod call, allowing the client to initiate a call and receive a stream of data sent by the server.\nParameters:\nrequest (Request Data): This is an object containing the request data. The structure of the request object depends on the message type defined in the .proto file of the gRPC service.\nmetadata (Metadata): This is an optional parameter used to pass metadata related to the request. Metadata is represented as key-value pairs and can contain data for purposes like authentication, authorization, tracking, or others.\noptions (Options): This is an optional parameter used to set specific call options. It's an object containing a set of key-value pairs that can be used to configure the call's behavior. Some available options include timeout duration, retry strategy, and more. If not provided, a default 10-second timeout will be set, and you can modify the timeout duration by passing deadline or timeout as options.\nReturn Value:\nStream instance providing a series of methods to handle client-side streaming.","readall#readAll()":"Description:\nReceive a stream of data sent by the server.\nParameters:\nvoid: No parameters.\nReturn Value:\nasyncIterator: An asyncIterator object returned by the server, requiring the use of for await to retrieve individual stream message results.","readend#readEnd()":"Description:\nReceive the server's status and metadata information.\nParameters:\nvoid: No parameters.\nReturn Value:\nobject: { status, metadata }\nstatus: The status after server-side processing.\nmetadata: Metadata information returned by the server.","duplex-stream#duplex stream":"Description:\nHandle a rpcDuplexStreamMethod call, providing the client with the ability to send a stream of data and receive a stream of data from the server.\nParameters:\nmetadata (Metadata): This is an optional parameter used to pass metadata related to the request. Metadata is represented as key-value pairs and can contain data for purposes like authentication, authorization, tracking, or others.\noptions (Options): This is an optional parameter used to set specific call options. It's an object containing a set of key-value pairs that can be used to configure the call's behavior. Some available options include timeout duration, retry strategy, and more. If not provided, a default 10-second timeout will be set, and you can modify the timeout duration by passing deadline or timeout as options.\nReturn Value:\nStream instance providing a series of methods to handle client-side streaming.","write-1#write()":"Description:\nThe client sends a stream of data.\nParameters:\nrequest (Request Data): This is an object containing the request data. The structure of the request object depends on the message type defined in the .proto file of the gRPC service.\nReturn Value:\nBoolean: Boolean value, typically true.","writeall-1#writeAll()":"Description:\nThe client\nsends multiple data entries in bulk.Parameters:\nrequest (Request Data): This is an object containing the request data. The structure of the request object depends on the message type defined in the .proto file of the gRPC service.\nReturn Value:\nvoid: No return value.","readall-1#readAll()":"Description:\nReceive a stream of data sent by the server.\nParameters:\nvoid: No return value.\nReturn Value:\nasyncIterator: An asyncIterator object returned by the server, requiring the use of for await to retrieve individual stream message results.","readend-1#readEnd()":"Description:\nReceive the server's status and metadata information.\nParameters:\nvoid: No parameters.\nReturn Value:\nobject: { status, metadata }\nstatus: The status after server-side processing.\nmetadata: Metadata information returned by the server.","proxycallmethod#proxy.call[method]":"Description:\nHandle a call.rpcMethod call, using a callback function and event listeners to process server information.\nParameters:\nrequest (Request Data): This is an object containing the request data. The structure of the request object depends on the message type defined in the .proto file of the gRPC service.\nmetadata (Metadata): This is an optional parameter used to pass metadata related to the request. Metadata is represented as key-value pairs and can contain data for purposes like authentication, authorization, tracking, or others.\noptions (Options): This is an optional parameter used to set specific call options. It's an object containing a set of key-value pairs that can be used to configure the call's behavior. Some available options include timeout duration, retry strategy, and more. If not provided, a default 10-second timeout will be set, and you can modify the timeout duration by passing deadline or timeout as options.\ncallback (Callback Function): This is a required parameter used to receive and process server-side error information and results.\nReturn Value:\nCall instance providing a series of methods to handle the client.","on#on()":"Description:\nListen for server events and handle the received data.\nParameters:\neventName (Required): Event name, including data, end, status, metadata, and error.\ncallback (Required): This is a callback function used to receive and process server-side error information and results.\nReturn Value:\nvoid: No return value.","write-2#write()":"Description:\nThe client sends a stream of data.\nParameters:\nrequest (Request Data): This is an object containing the request data. The structure of the request object depends on the message type defined in the .proto file of the gRPC service.\nReturn Value:\nBoolean: Boolean value, typically true.","end#end()":"Description:\nSignal to the server that the client has finished sending stream data.\nParameters:\nvoid: No parameters.\nReturn Value:\nvoid: No return value."}},"/en-US/guide/config":{"title":"Config","data":{"":"gRPCity has two important configurations related to proto: loadOptions and channelOptions. Both are used in init(), while initClients() and initServer() use only channelOptions.\nloadOptions: Corresponds to the rule configuration when loading proto files.\nchannelOptions: Corresponds to the rule configuration for communication between the server and the client.","loadoptions#loadOptions":"The fields included in loadOptions are described as follows:\nField Name\tValid Values\tDescription\tkeepCase\ttrue or false\tPreserve field names. By default, they are changed to camel case.\tlongs\tString or Number\tType used to represent long values. Default is the Long object type.\tenums\tString\tType used to represent enum values. Default is a numeric type.\tbytes\tArray or String\tType used to represent bytes values. Default is Buffer.\tdefaults\ttrue or false\tSet default values on the output object. Default is false.\tarrays\ttrue or false\tSet empty arrays for missing array values, even if defaults is false. Default is false.\tobjects\ttrue or false\tSet empty objects for missing object values, even if defaults is false. Default is false.\toneofs\ttrue or false\tSet virtual oneof properties as field names. Default is false.\tjson\ttrue or false\tRepresent Infinity and NaN as strings in float fields and automatically decode google.protobuf.Any values. Default is false.\tincludeDirs\tArray of strings\tList of search paths for imported .proto files.\t\nThe default loadOptions for gRPCity is:","channeloptions#channelOptions":"channelOptions aligns with the grpc-js official specifications, and you can see all the channel configuration options here. The currently supported configuration options can be found here.The default channelOptions for gRPCity is:"}},"/en-US/guide/metadata":{"title":"Metadata","data":{"":"Metadata functionality is essential in gRPC. In some scenarios, we need capabilities similar to HTTP headers, such as tracing, source of the request, and more. Metadata serves these purposes.","client-side-metadata-sending#Client-Side Metadata Sending":"To send metadata from the client, you need to call loader.makeMetadata(). Here's an example of how to use it:\nWhen we print the metadata, the result is as follows:\nIt's important to note that there are some default values in the metadata, such as:For gRPCity Clients, the following metadata is sent by default:\nx-client-hostname: This is set to the hostname of the operating system.\nx-client-app-name: This is set to the appName used during loader initialization.\nFor gRPCity Servers, the following metadata is sent by default:\ncontent-type: This is generally set to application/grpc+proto.\nuser-agent: This is generally set to grpc-node-js/1.9.7.\ndate: This is generally set to the current date.","server-side-metadata-reception#Server-Side Metadata Reception":"The server can receive metadata in the call.metadata object. To use it, you need to clone() it and then retrieve values based on the keys.\nThe output will look like this:","server-side-metadata-sending#Server-Side Metadata Sending":"In some cases, you might want the server to send metadata back to the client. You can do so as follows:\nWhen the server sends metadata, the client can receive it."}},"/en-US/guide/error":{"title":"Error","data":{"":"Error handling is an important aspect of ensuring the smooth operation of services. gRPCity provides convenient error handling mechanisms.\nIn general, it is recommended to use try/catch for error catching and throw to expose errors.","client-side-error-handling#Client-Side Error Handling":"When a client calls a server, if the server encounters an error, it will return an ERROR object with the following four fields:\nname: The value is GrpcClientError, which can be used to determine if it is a client-side RPC error.\ncode: gRPC Status Code.\nmessage: The error message emitted by the gRPC server.\nstack: The error trace stack from the server.\nThe expanded ERROR object looks like this:","server-side-error-triggering#Server-Side Error Triggering":"The following example shows how the server can proactively trigger an error when the client sends x-throw-error metadata,\nand the sayHello() method on the server checks for this metadata:\nWhen the server proactively triggers an error, the error is caught by the client and reported as shown in the client-side error handling example above."}},"/en-US/guide/middleware":{"title":"Middleware","data":{"":"Middleware is an essential feature in gRPCity, providing the ability to execute middleware code before and after handling RPC calls.\nMiddleware plays a convenient role in scenarios such as uniform call logging, monitoring metric collection, authentication, parameter modification, result modification, and delay.\nThis helps improve development efficiency in handling business logic.The middleware implementation in gRPCity is based on the koa-compose library, which provides an onion model working mechanism for executing middleware.Suppose we have three middleware functions: A, B, and C. The order in which middleware is executed is A -> B -> C. Here's how it works:","usage#Usage":"gRPCity server provides two methods to support middleware: server.addMiddleware(fn) and server.addMiddlewares(fns).The difference between the two methods is that one can only pass a single middleware, while the other can accept multiple middlewares, as follows:\nYou can add middleware after initializing the server with initServer() and before calling listen().","writing-middleware#Writing Middleware":"Here, we will demonstrate how to write middleware for logging RPC calls.Middleware functions support two parameters: ctx and next, as follows:\nctx: An object that represents the middleware context.\npath: The RPC route path.\nrequest: The RPC request parameters.\nmetadata: Metadata from the client.\nresponse: The result returned by the RPC method, which is available only after the RPC method is executed.\nnext: A function that executes the next middleware or the actual method.\nTo add the middleware:\nWith these steps, you have completed writing and using middleware."}},"/en-US/guide/proto":{"title":"Proto","data":{"":"Sometimes, we need the ability to work with the contents of a proto file. The gRPCity library provides these capabilities, which are also called internally. For example, addService(serviceName, implementation) requires obtaining the service name defined in the proto file.The benefit of this is that it adds an additional layer of validation to ensure the correctness of the service.","loading-proto-files#Loading Proto Files":"Suppose we have a proto path protos/test/helloworld/ with the following proto content:\nWe first need to load the proto:","servicename#service(name)":"The name parameter specifies the route of the proto, including the service location.","typename#type(name)":"The name parameter specifies the route of the proto, including the package, service, model, or message.The type() method includes the capabilities of service().","messagename#message(name)":"The name parameter specifies the route of the proto and the name of the message.","encoding-and-decoding#Encoding and Decoding":"","note#Note":"In most cases, you only need to be concerned with the usage of service() and message(). The usage of type() is rare."}},"/en-US/guide/credentials":{"title":"Credentials","data":{"":"gRPC is built on top of the HTTP/2 protocol and provides strong support for TLS. By default, gRPCity skips server certificate verification when certificate authentication is not required. Communication between gRPC services and clients without certificates is done in plaintext, making the information susceptible to eavesdropping by any third party. To ensure gRPC communication is not intercepted, tampered with, or spoofed by third parties, you can enable TLS encryption on the server.Note: Enabling TLS increases CPU resource consumption. If your use case involves high QPS (Queries Per Second), it is not recommended to enable TLS.","generating-certificates#Generating Certificates":"To create your SSL certificates, you first need to generate SSL certificates for both the server and the client. You can use OpenSSL commands to generate your own certificates.We'll use a bash script to generate certificates and set global variables like passwords and certificate validity period.","generating-the-ca-certificate#Generating the CA Certificate":"","generating-the-server-certificate#Generating the Server Certificate":"","generating-the-client-certificate#Generating the Client Certificate":"After completing these steps, you will have a directory structure like this:","server-configuration#Server Configuration":"Now, let's configure the server with the generated certificates. Use server.makeServerCredentials() to load the certificates.The parameters for server.makeServerCredentials(rootCerts, keyCertPairs, checkClientCertificate) are as follows:\nrootCerts: The root certificate, usually the CA certificate.\nkeyCertPairs: An array of key and certificate pairs.\ncheckClientCertificate: Whether to check the client certificate.\nExample:\nNote: When using certificates, you cannot start the server using an IP address; you must use localhost or a domain name.","client-configuration#Client Configuration":"Now, let's configure the client with the generated certificates. Use loader.makeCredentials() to load the certificates.\nOnce you have the credentials, there are two ways to load them, as shown below:","loading-with-initclients#Loading with initClients()":"","loading-with-client#Loading with client()":"Notes:\ninitClients() is suitable for scenarios where all servers use the same certificate.\nclient() is suitable for scenarios where only a few servers have certificates or different servers use different certificates."}},"/en-US/guide/loader":{"title":"Loader","data":{"":"When using Proto Loader, you only need to provide parameters when creating an instance.\nWhy are the parameters location and files used?\nlocation refers to the directory containing the proto files, including the proto files referenced by the services, such as model.proto and empty.proto.\nfiles specifies the specific service.proto files, indicating where the service definitions are located.\nBenefits:\nService loading is clear, and you know which services will be used.\nThe directory structure of proto files can be customized without affecting the loading process.","directory-retrieval#Directory Retrieval":"For ESM module code file directory retrieval, use the following:\nIf you are using CommonJS module code, __dirname is globally available, so you can use it directly where needed.","loading-a-single-directory#Loading a Single Directory":"In most cases, you only need to load a single proto directory and specify multiple services as shown below:","loading-multiple-directories#Loading Multiple Directories":"Sometimes, you need to make service calls across different business domains, which may require loading multiple proto directories. Our gRPCity already supports loading multiple proto directories as shown below:","initialization-with-init#Initialization with init()":"Why does the loader need init()?init() is where the actual proto loading is performed. It also serves as a place for customizing parameters and environment configuration. It can be placed as the first step in the service framework process and only needs to be executed once.","explanation-of-options#Explanation of Options":"The options parameter includes the following options:\nservices: (Optional) Similar to the parameters in initClient(). If provided, it allows you to skip initClient() and directly complete the initialization of the client. It supports both string and object parameters.\nString: IP+port format, such as 127.0.0.1:9099.\nObject: { host, port }.\nhost: A string supporting both IP and domain names.\nport: A number with a minimum value of 0 and a maximum value of 65535.\nisDev: (Optional) A boolean indicating whether it is in development mode.\npackagePrefix: (Optional) A string representing the package name prefix of the service, e.g., dev, stage, etc.\nloadOptions: (Optional) Proto load options.\nchannelOptions: (Optional) Proto channel options.\nappName: (Optional) A string representing the name of the current application for identification purposes.\nFor more information on loadOptions and channelOptions, please refer to this guide: Config.","examples#Examples":"Note that when using packagePrefix, the server and client should be consistent.For the test environment, the configuration is as follows:\nFor the stage environment, the configuration is as follows:\nFor the production environment, simply ignore some configuration options, as follows:"}},"/en-US/guide/server":{"title":"Server","data":{"":"The Server is one of the core features of gRPCity, providing the ability to manage the server lifecycle.\nIt offers a range of interface functions for managing the entire lifecycle, from importing certificates, binding services, supporting middleware, starting services, and shutting down services.","server-instance#Server Instance":"channelOptions are explained in detail in the Config guide.\nOnce you have the server instance, it offers a series of interfaces to help you develop services.","service-binding#Service Binding":"Service binding requires two parameters: service and implementation.\nservice: (required) Obtain the specified service from the proto file using loader.service(name).\nimplementation: (required) An object or class that carries the methods defined by the service RPC. You need to asyncify it using loader.callbackify() and add support for middleware.","adding-middleware#Adding Middleware":"A distinctive feature of gRPCity Server is that it provides middleware capabilities for pre- and post-processing of implementation. For more details, see the Middleware guide.Note: Only service RPCs bound using loader.callbackify() support middleware.","certificates-and-startup#Certificates and Startup":"To start the service, the listen function supports two parameters: addr and credentials:\naddr: (required) The address and port on which the service needs to listen. You can provide either of the following, either as a string or as an object (choose one):\nstring: in the format ip+port, such as 127.0.0.1:9099;\nobject: { host, port }:\nhost: a string, supports both IP addresses and domain names;\nport: a number, with a minimum value of 0 and a maximum value of 65535;\ncredentials: (optional) Generated using makeServerCredentials and provided to the listen call.\nFor more information, you can read the Credentials guide.","service-shutdown#Service Shutdown":"Use shutdown() with async to ensure that it completes asynchronously, while forceShutdown doesn't require async."}},"/en-US/guide/stream":{"title":"Stream","data":{"":"The gRPCity library provides complete stream processing capabilities, allowing you to implement business scenarios such as file uploads, event mechanisms, task monitoring, metric reporting and etc.\nCurrently, there are three types of streaming RPCs: client-stream to server, client to server-stream, and client-stream to server-stream.Here, we'll demonstrate how to work with streams using callbacks and event mechanisms. We will use the proxy.call methods of the client.If you need to learn about working with async streams, you can refer to the Stream v2 guide.","prerequisites#Prerequisites":"In our proto file, the RPCs in the service must be clearly marked as using stream. Here is an example:\nClientStreamHello: Indicates that only the client uses Stream.\nServerStreamHello: Indicates that only the server uses Stream.\nMutualStreamHello: Indicates that both the client and the server use Stream.\nWrite loader.js to complete proto loading:","server#Server":"Write the Stream class, which provides three server streaming functions: clientStreamHello(), serverStreamHello(), and mutualStreamHello().\nContinue with service initialization and startup:","client#Client":"To call the server using the Stream client, you need to use the functions inside .call.. Here's an example:","testing#Testing":"client stream to server: We only execute the client's clientStreamHello() function, and the result is as follows:\nServer:\nClient:\nclient to server stream: We only execute the client's serverStreamHello(), and the result is as follows:\nServer:\nClient:\nclient stream to server stream: We only execute the client's mutualStreamHello(), and the result is as follows:\nServer:\nClient:\nThis demonstrates the use of different stream types between the client and server in gRPC."}},"/en-US/guide/status":{"title":"Status","data":{"":"The gRPCity library provides a convenient way to obtain status. In general, you won't need to use it often, but I'll provide a brief overview here.","getting-status#Getting Status":"Obtaining the status returned by the server is straightforward for the client, as shown below:","status-codes#Status Codes":"The default status codes and their descriptions are as follows:\nCode\tNumber\tDescription\tOK\t0\tNo error; indicates a successful return.\tCANCELLED\t1\tThe operation was cancelled, typically by the caller.\tUNKNOWN\t2\tUnknown error. For example, when a status value received from a different address space is unknown within this address space, this error may be returned. It may also be used to translate errors that are not returned with sufficient detail by APIs.\tINVALID_ARGUMENT\t3\tThe client specified an invalid argument. Note that this differs from \"FAILED_PRECONDITION.\" \"INVALID_ARGUMENT\" indicates arguments that are problematic regardless of the system state (e.g., a file format error).\tDEADLINE_EXCEEDED\t4\tThe deadline expired before the operation could complete. For operations that change the system state, this error may be returned even if the operation has completed successfully. For example, a successful response from a server that was delayed long enough for the client to disconnect may lead to this error.\tNOT_FOUND\t5\tSome requested entity (e.g., file or directory) was not found. Server developers should consider returning \"NOT_FOUND\" if an RPC should be rejected for an entire class of users, such as gradual feature rollout or undocumented whitelist. If a request is rejected for some users in a user class based on, for example, user-based access control, \"PERMISSION_DENIED\" must be used.\tALREADY_EXISTS\t6\tThe client attempted to create an entity (e.g., a file or directory) that already exists.\tPERMISSION_DENIED\t7\tThe caller does not have permission to execute the specified operation. \"PERMISSION_DENIED\" must not be used for errors caused by exhausting some resource (use \"RESOURCE_EXHAUSTED\" instead). \"PERMISSION_DENIED\" must not be used if the caller cannot be identified.\tRESOURCE_EXHAUSTED\t8\tSome resource has been exhausted, such as a per-user quota, or the entire file system is out of space.\tFAILED_PRECONDITION\t9\tThe operation was rejected because the system is not in a state required for the operation. For example, an attempt to delete a directory that is non-empty, even though it is a directory, would result in \"FAILED_PRECONDITION.\" Service implementers can use the following guidelines to choose between \"FAILED_PRECONDITION,\" \"ABORTED,\" and \"UNAVAILABLE\": (a) If the client can retry the failed call, use \"UNAVAILABLE.\" (b) If the client should not retry at a higher level, use \"ABORTED\" (for example, when a client specifies a test and the set fails). (c) If the client should not retry until the system state is fixed, use \"FAILED_PRECONDITION.\" For example, if a directory is not empty, \"rmdir\" should fail because the client should not retry unless it first removes the files from the directory.\tABORTED\t10\tThe operation was aborted, typically due to a concurrency issue, such as a sequencer check failure or a transaction abort. Service implementers can use the following guidelines to choose between \"FAILED_PRECONDITION,\" \"ABORTED,\" and \"UNAVAILABLE\": (a) If the client can retry the failed call, use \"UNAVAILABLE.\" (b) If the client should retry at a higher level, use \"ABORTED\" (for example, when a client specifies a test and the set fails). (c) If the client should not retry until the system state is fixed, use \"FAILED_PRECONDITION.\" For example, \"rmdir\" might fail if it is called on a non-empty directory, but the client should not retry until it removes the files from the directory.\tOUT_OF_RANGE\t11\tThe operation was attempted past the valid range. For example, reading or writing past the end of a file. Unlike \"INVALID_ARGUMENT,\" this error indicates a problem that may be fixed if the system state changes. For example, if a 32-bit file system is asked to read at a certain offset that is not in the range [0,2^32-1], it will generate \"INVALID_ARGUMENT,\" but if asked to read from an offset that is past the current file size, it will generate \"OUT_OF_RANGE.\" \"RESUMED: FAILED_PRECONDITION\" and \"OUT_OF_RANGE\" have a small overlap. We recommend using \"OUT_OF_RANGE\" (the more specific error) when it is applicable so that callers who iterate through space can easily locate \"OUT_OF_RANGE\" errors.\tUNIMPLEMENTED\t12\tThe operation is not implemented or not supported/enabled in this service.\tINTERNAL\t13\tInternal error. This means that some invariant expected by the underlying system has been broken. This error code is reserved for serious errors.\tUNAVAILABLE\t14\tThe service is currently unavailable. This is most likely a transient condition that can be corrected by retrying with an exponential backoff. Note that it is not always safe to retry non-idempotent operations.\tDATA_LOSS\t15\tUnrecoverable data loss or corruption.\tUNAUTHENTICATED\t16\tThe request does not have valid authentication credentials.","status-cases#Status Cases":"In addition to \"OK,\" you should also be aware of the possible reasons for other Code values, as shown in the following table:\nCase\tCode\tClient or Server\tThe client's application cancelled the request\tCANCELLED\tBoth\tThe deadline expired before the server returned a status\tDEADLINE_EXCEEDED\tBoth\tThe method was not found on the server\tUNIMPLEMENTED\tServer\tThe server is shutting down\tUNAVAILABLE\tServer\tThe server application throws an exception (or performs an action other than returning a status code, terminating the RPC)\tUNKNOWN\tServer\tThe deadline expired before a response was received. This can happen when the client is unable to send the request to the server or the server is slow to respond.\tDEADLINE_EXCEEDED\tBoth\tSome data was sent before the connection was terminated (e.g. writing request metadata to the TCP connection)\tUNAVAILABLE\tClient\tThe server was unable to decompress data, although the compression algorithm was supported (client to server)\tINTERNAL\tServer\tThe server was unable to decompress data, although the compression algorithm was supported (server to client)\tINTERNAL\tClient\tThe compression mechanism used by the client is not supported on the server\tUNIMPLEMENTED\tServer\tThe server's temporary resources are exhausted (e.g. reaching the rate-limiting resource limit)\tRESOURCE_EXHAUSTED\tServer\tThe client does not have enough memory to store the server's response\tRESOURCE_EXHAUSTED\tClient\tA traffic control protocol violation occurred\tINTERNAL\tBoth\tAn error occurred while parsing the returned status\tUNKNOWN\tClient\tInvalid authentication metadata (credentials couldn't be obtained from the metadata, incompatible credentials set on the channel and call, invalid host set in :authority metadata, etc.)\tUNAUTHENTICATED\tBoth\tRequest cardinality violation (method requires exactly one request, but the client sent a different number of requests)\tUNIMPLEMENTED\tServer\tResponse cardinality violation (method requires exactly one response, but the server sent a different number of responses)\tUNIMPLEMENTED\tClient\tAn error occurred while parsing the response protocol\tINTERNAL\tClient\tAn error occurred while parsing the request protocol\tINTERNAL\tServer\tMessages sent or received were larger than the configured limit\tRESOURCE_EXHAUSTED\tBoth\tKeepalive monitor timeout\tUNAVAILABLE\tBoth"}},"/en-US/start/client":{"title":"Client Side","data":{"":"Developing the client-side is relatively simpler. Here, you can see how to easily make calls to two different gRPC servers.","project-structure#Project Structure":"We've already created client.js in the original project.","initialization#Initialization":"Step 1: Import the loader.js module, which we'll use in the subsequent development to bind methods with RPC and the server.\nStep 2: Initialize the client, passing in the server name and address.","invocation-and-start#Invocation and Start":"We then add client-side logic for invoking the server and print the results in the start method.After the client sends a request, the result received includes three values: status, metadata, and response.\nstatus: The server's state after execution.\nmetadata: Metadata information sent by the client and returned by the server.\nresponse: The result returned by the server after processing.","testing#Testing":"In the previous server-side tutorial, we've already started two servers. So, executing the client is all that's needed to complete integration testing.\nThe results of the first execution are as follows:\nThe results of the second execution are as follows:\nWe can see that both executions return results as expected, and the count in the sayGreet method accumulates to 2 after the second execution, indicating the successful completion of this client-to-server interaction loop.You can find the project repository for the Quick Start tutorial here: link.The introductory tutorial is now complete, and it should feel quite simple and user-friendly. Feel free to revisit and further your learning."}},"/en-US/start":{"title":"Get Started","data":{"":"We assume that you already have a basic understanding of gRPC, Node.js, and JavaScript.\nThe official documentation is the best teacher, and for a basic introduction to gRPC,\nwe recommend the following link.The quick start tutorial will be divided into three parts, ultimately guiding you\nthrough the development of a complete microservices server using gRPCity and client-side invocation.The project code corresponding to the introductory tutorial is already available on GitHub. link ã€‚"}},"/en-US":{"title":"gRPCity","data":{"":"gPRCity is a simple, easy-to-use, and advanced gRPC microservices library based on Node.js.\nThe name is derived from \"gRPC + City = gRPCity\", symbolizing the author's hope that this library can support the development of business cities. Taking a technological perspective as the foundation, it enables everyone to focus on business and better support delivery. Here, I would like to recommend a game called \"Cities: Skylines 2.\" It is a city simulation game that allows players to experience the excitement and challenges of creating and maintaining a real city firsthand.","code-hub#Code Hub":"GitHub: https://github.com/chakhsu/grpcity\nnpm: https://www.npmjs.com/package/grpcity","target#Target":"Committed to providing a comprehensive Node.js-based, gRPC-based microservices development experience. Offering the Node.js community and developers an additional choice for microservices libraries with enhanced features.\nBuilding two foundations: a microservices library technical foundation and a business support foundation.","principle#Principle":"Focus: Specialize in a gRPC microservices library, not a one-size-fits-all framework.\nSimplicity: Provide a simple and clear API that is easy to understand and quick to get started with.\nUsability: Simplify complex concepts as much as possible, offering clear and easy-to-follow code.\nStability: High testability, extensive coverage, and a proven track record of reliability in online deployments.\nCollaboration: Leverage the Node.js community and ecosystem to the fullest extent.","features#Features":"API: The communication protocol is based on gRPC and defined using Protobuf.\nProtobuf: Supports only dynamic loading of pb, simplifying the loading process of pb files.\nClient: Configured once and can be called anytime, anywhere, supporting multi-server invocation.\nServer: Simplifies the initialization process, starting the server in three steps, supporting multi-server startup.\nNo-Route: No routing, RPC is inherently bound to methods.\nMiddleware: Integrates middleware mechanism similar to Koa, providing pre and post-processing capabilities for RPC.\nMetadata: Standardizes the transmission and retrieval of metadata.\nError: Provides dedicated Error objects to ensure targeted handling of exceptions after catching.\nPromise: Supports promisify internally in RPC methods while also preserving callbackify.\nConfig: Aligned with official configurations, supports pb load configuration and gRPC channel configuration.\nPattern: Singleton pattern ensures the uniqueness of instance objects.\nTypescript: Supported, ensuring compatibility between TS and JS.\n...and a lot more."}},"/en-US/guide/stream-v2":{"title":"Stream v2","data":{"":"Starting from version 0.9, gRPCity provides full promisify capabilities for calling streaming RPCs from the client, allowing you to use async/await syntax for stream processing.Here, we will demonstrate how to use the capabilities of Stream v2. We recommend reading the Stream guide first, as there will be some similarities in this guide.Note: The server used in this guide is based on the server defined in Stream.","define-proto#Define Proto":"The proto file defines three RPCs, each corresponding to one of the three ways to connect the client and server: client-stream, client-server-stream, and bidirectional-stream.","load-proto#Load Proto":"","client#Client":"Some preliminary work on the client, such as loading the proto, initializing the client, and creating new metadata.","client-stream#Client-Stream":"Client-stream means client stream request -> server response.We continue the process of client-stream within the start method:\nThe running result is as follows. We see that writeEnd() returns the server response for this call: { status, metadata, response }. At the same time, the stream message has been sent to the server.","server-stream#Server-Stream":"Server-stream means client request -> server stream response.We continue the process of server-stream within the start method:\nThe running result is as follows:We see that readAll() returns an asyncIterator, which requires us to use for await to obtain the results of individual stream messages returned by the server. The readEnd() returns { status, metadata }. We also see the server's log records, and we received the message sent by the client.","bidirectional-stream#Bidirectional-Stream":"Bidirectional-stream means client stream request -> server stream response.We continue the process of bidirectional-stream within the start method. First, we call writeAll() to send 3 messages, then we call write() to send 1 message, and finally, we call readAll() to get the results returned by the server.\nThe running result is as follows. We see that we first send messages from the client to the server, and then we call readAll() to get an asyncIterator, which requires us to use for await to obtain the results of individual stream messages returned by the server. Finally, we call readEnd() to get the server's end stream information, returned as { status, metadata }.\nThis demonstrates how to work with different types of streams between the client and server in gRPC using the Stream v2 feature."}},"/en-US/start/proto-loader":{"title":"Proto loader","data":{"":"The official provides two ways to load protobuf files. One is to directly load .pb files, and the other is to use tools to compile and reference dependencies. In this case, gRPCity ultimately chose to support only the first method, which is to load .pb files directly.Next, we'll get started by creating a new project. You can find the demo project repository here: link.","initialization-and-installation#Initialization and Installation":"Create a demo project and navigate to it:\nInitialize the project:\nInstall the dependencies:\nNote: We need to add \"type\": \"module\" to package.json to activate ESM modules.","project-structure#Project Structure":"We need to create a series of directories and files. The final project directory and file structure will look like this:","define-the-proto#Define the Proto":"Create a proto directory and create the service.proto file:\nDefine two services in service.proto: Greeter and Hellor. Also, split the message into the model.\nEnter the following content into service.proto:\nCreate a model directory and create the message.proto file:\nEnter the following content into message.proto:","load-pb--modularize#Load PB & Modularize":"Import the grpcity dependency and create an instance. Note that you need to provide two parameters: location and files, which represent the root directory of proto files and the specific proto files, respectively.\nWith this, we have completed the loading of proto files and obtained loader.js. You can now import this file anywhere and use it to develop client-side or server-side applications. It's that simple! Compared to the official approach, this library simplifies the complex definitions and only requires you to pass the files to the corresponding object for file loading.Now, let's proceed with the development of the client or server side."}},"/en-US/start/server":{"title":"Server Side","data":{"":"In the previous tutorial, we obtained loader.js, a module that handles the loading of proto files. In this tutorial, we will use this module to develop the server-side of our application. Let's get started!We will provide two different approaches to meet different scenario requirements.","project-structure#Project Structure":"In our existing project, we have already created server.js and server2.js, which correspond to two different approaches.","approach-1-recommended#Approach 1 (Recommended)":"Step 1: Import the loader.js module, which we will use in the subsequent development to bind RPC and server methods.","define-classes#Define Classes":"Step 2: Define the Greeter class.\nStep 3: Continue to define the Hellor class in the same way.","binding-and-start#Binding and Start":"","approach-2#Approach 2":"We perform coding in server2.js.Step 1: Import the loader.js module, which we will use in the subsequent development to bind RPC and server methods.","define-objects#Define Objects":"Step 2: Define the Greeter object.\nStep 3: Continue to define the Hellor object in the same way.","binding-and-start-1#Binding and Start":"","integration#Integration":"As you can see, both Approach 1 and Approach 2 register multiple services in the same server. The reason we recommend Approach 1 is that it is more modular and allows you to separate classes into individual files, decoupling the workflow from business logic and increasing service extensibility.In Approach 2, we demonstrate support for two types of RPC methods: promise style and callback style. Generally, we use the promise style for RPC methods.We will start both of these servers, and in the upcoming client-side tutorial, we will make calls to both of these servers to complete the gRPC calling cycle. The details of the integration process will be covered in the client-side tutorial.\nOnce started, our client can connect to the respective addresses for access and calls.Now, let's move on to the development of the client-side."}}}