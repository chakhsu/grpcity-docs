{"/zh-CN/apis":{"title":"API","data":{"":"下面我们将会展示所有给开发者提供用于生产开发的gRPCity的 API. API 将会分成3部分，分别是loader、server和client。"}},"/zh-CN/apis/client-proxy":{"title":"Client Proxy","data":{"proxymethod#proxy[method]":"","unary#unary":"功能说明:\n发一次rpcUnaryMethod调用，点对点，并等待直至结果返回。\n参数说明:\nrequest（请求参数）: 这是一个包含请求数据的对象。请求对象的结构取决于定义的 gRPC 服务的.proto文件中的消息类型；\nmetadata（元数据）: 这是一个可选参数，用于传递与请求相关的元数据。元数据是以键值对的形式表示的信息，可以包含用于身份验证、授权、跟踪或其他目的的数据；\noptions（选项）: 这是一个可选参数，用于设置特定的调用选项。它是一个包含一组键值对的对象，可用于配置调用的行为。一些可用的选项包括超时时间、重试策略等。如果不传该参数，默认会设置10秒超时，可以通过传入deadline或timeout的方式修改超时时间；\n返回值:\nobject: { status, metadata, response }\nstatus: 服务端处理执行后的状态；\nmetadata: 服务端返回的 metadata 信息；\nresponse: 服务端处理完成后响应的结果；","client-stream#client stream":"功能说明:\n处理一次rpcClientStreamMethod调用，提供客户端发送流信息的能力和获取服务端处理完流的结果的能力。\n参数说明:\nmetadata（元数据）: 这是一个可选参数，用于传递与请求相关的元数据。元数据是以键值对的形式表示的信息，可以包含用于身份验证、授权、跟踪或其他目的的数据；\noptions（选项）: 这是一个可选参数，用于设置特定的调用选项。它是一个包含一组键值对的对象，可用于配置调用的行为。一些可用的选项包括超时时间、重试策略等。如果不传该参数，默认会设置10秒超时，可以通过传入deadline或timeout的方式修改超时时间；\n返回值:\nstream 实例，提供一系列方法处理客户端流。","write#write()":"功能说明:\n客户端发送一条流信息。\n参数说明:\nrequest（请求参数）: 这是一个包含请求数据的对象。请求对象的结构取决于定义的 gRPC 服务的.proto文件中的消息类型；\n返回值:\nBoolean: 布尔值，一般为true;","writeall#writeAll()":"功能说明:\n客户端批量发送多条流信息。\n参数说明:\nrequest（请求参数）: 这是一个包含请求数据的对象。请求对象的结构取决于定义的 gRPC 服务的.proto文件中的消息类型；\n返回值:\nvoid: 空。","writeend#writeEnd()":"功能说明:\n获取服务端处理完流信息的结果。\n参数说明:\nvoid: 空。\n返回值:\nobject: { status, metadata, response }\nstatus: 服务端处理执行后的状态；\nmetadata: 服务端返回的 metadata 信息；\nresponse: 服务端处理完成后响应的结果；","server-stream#server stream":"功能说明:\n处理一次rpcServerStreamMethod调用，提供客户端发起一次调用的能力和获取服务端发送的流信息的能力。\n参数说明:\nrequest（请求参数）: 这是一个包含请求数据的对象。请求对象的结构取决于定义的 gRPC 服务的.proto文件中的消息类型；\nmetadata（元数据）: 这是一个可选参数，用于传递与请求相关的元数据。元数据是以键值对的形式表示的信息，可以包含用于身份验证、授权、跟踪或其他目的的数据；\noptions（选项）: 这是一个可选参数，用于设置特定的调用选项。它是一个包含一组键值对的对象，可用于配置调用的行为。一些可用的选项包括超时时间、重试策略等。如果不传该参数，默认会设置10秒超时，可以通过传入deadline或timeout的方式修改超时时间；\n返回值:\nstream 实例，提供一系列方法处理客户端流。","readall#readAll()":"功能说明:\n接收服务端返回流信息。\n参数说明:\nvoid: 空。\n返回值:\nasyncIterator:服务端返回的一个asyncIterator对象，需要我们使用for await获取服务端返回的逐条stream message结果；","readend#readEnd()":"功能说明:\n接收服务端返回的状态和metadata元信息。\n参数说明:\nvoid: 空。\n返回值:\nobject: { status, metadata }\nstatus: 服务端处理执行后的状态；\nmetadata: 服务端返回的 metadata 信息；","duplex-stream#duplex stream":"功能说明:\n处理一次rpcDuplexStreamMethod调用，提供客户端发送流信息的能力和获取服务端发送的流信息的能力。\n参数说明:\nmetadata（元数据）: 这是一个可选参数，用于传递与请求相关的元数据。元数据是以键值对的形式表示的信息，可以包含用于身份验证、授权、跟踪或其他目的的数据；\noptions（选项）: 这是一个可选参数，用于设置特定的调用选项。它是一个包含一组键值对的对象，可用于配置调用的行为。一些可用的选项包括超时时间、重试策略等。如果不传该参数，默认会设置10秒超时，可以通过传入deadline或timeout的方式修改超时时间；\n返回值:\nstream 实例，提供一系列方法处理客户端流。","write-1#write()":"功能说明:\n客户端发送一条流信息。\n参数说明:\nrequest（请求参数）: 这是一个包含请求数据的对象。请求对象的结构取决于定义的 gRPC 服务的.proto文件中的消息类型；\n返回值:\nBoolean: 布尔值，一般为true;","writeall-1#writeAll()":"功能说明:\n客户端批量发送多条流信息。\n参数说明:\nrequest（请求参数）: 这是一个包含请求数据的对象。请求对象的结构取决于定义的 gRPC 服务的.proto文件中的消息类型；\n返回值:\nvoid: 空。","readall-1#readAll()":"功能说明:\n接收服务端返回流信息。\n参数说明:\nvoid: 空。\n返回值:\nasyncIterator:服务端返回的一个asyncIterator对象，需要我们使用for await获取服务端返回的逐条stream message结果；","readend-1#readEnd()":"功能说明:\n接收服务端返回的状态和metadata元信息。\n参数说明:\nvoid: 空。\n返回值:\nobject: { status, metadata }\nstatus: 服务端处理执行后的状态；\nmetadata: 服务端返回的 metadata 信息；","proxycallmethod#proxy.call[method]":"功能说明:\n处理一次call.rpcMethod调用，使用回调函数和事件监听的机制处理服务端的信息。\n参数说明:\nrequest（请求参数）: 这是一个包含请求数据的对象。请求对象的结构取决于定义的 gRPC 服务的.proto文件中的消息类型；\nmetadata（元数据）: 这是一个可选参数，用于传递与请求相关的元数据。元数据是以键值对的形式表示的信息，可以包含用于身份验证、授权、跟踪或其他目的的数据；\noptions（选项）: 这是一个可选参数，用于设置特定的调用选项。它是一个包含一组键值对的对象，可用于配置调用的行为。一些可用的选项包括超时时间、重试策略等。如果不传该参数，默认会设置10秒超时，可以通过传入deadline或timeout的方式修改超时时间；\ncallback (回调函数) : 这是一个必选项，用来接收并处理服务端返回错误信息和结果;\n返回值:\ncall 实例，提供一系列方法处理客户端。","on#on()":"功能说明:\n监听服务端事件，并处理监听数据。\n参数说明:\neventName: (必选) 事件名，有：data, end, status, metadata和error;\ncallback: (必选) 这是一个回调函数，用来接收并处理服务端返回错误信息和结果;\n返回值:\nvoid: 空。","write-2#write()":"功能说明:\n客户端发送一条流信息。\n参数说明:\nrequest（请求参数）: 这是一个包含请求数据的对象。请求对象的结构取决于定义的 gRPC 服务的.proto文件中的消息类型；\n返回值:\nBoolean: 布尔值，一般为true;","end#end()":"功能说明:\n客户端发送流信息已结束的信号给服务端。\n参数说明:\nvoid: 空。\n返回值:\nvoid: 空。"}},"/zh-CN/apis/grpcloader":{"title":"gRPC Loader API","data":{"class-grpcloader#class GrpcLoader":"参数说明:\narray: [ { location, files } ], 支持数组对象;\nsingle: { location, files }, 支持单对象;\n其中，{ location, files }说明:\nlocation: (必选) path string, 例如: path.join(__dirname, './proto');\nfiles: (必选) array string, 例如: ['path/to/service-a.proto', 'path/to/service-b.proto']\n返回值:\n返回已经创建好的 GrpcLoader 实例，包含一系列内部变量、内部方法和外部方法。\n下面将会展示GrpcLoader里的 API","init#init()":"功能说明:\n初始化，可以初始化所有客户端，实现 service proto 定义与服务端地址绑定，同时支持环境配置。\n参数说明:\nservices: (任选一) 跟initClient()里的参数一样，如果有这个参数，则可以跳过initClient，直接完成client的初始化。同时支持字符串和对象参数；\nstring: (任一) ip+port 格式，如 127.0.0.1:9099；\nobject: (任一) { host, port }；\nhost: 字符串，支持 ip 和域名；\nport: 数字，最小值为0，最大值为65535；\nisDev: (可选) 布尔值，是否为开发模式；\npackagePrefix: (可选) 字符串，service name 包前缀，如: dev, stage等等；\nloadOptions: (可选) proto load options；\nchannelOptions: (可选) proto channel options；\nappName: (可选) 字符串，当前应用的应用名，用来标记；\n返回值:\nvoid: 空。","initclients#initClients()":"功能说明:\n初始化所有客户端，实现 service proto 定义与服务端地址绑定。\n参数说明:\nservices: (任选一) 跟initClient()里的参数一样，如果有这个参数，则可以跳过initClient，直接完成client的初始化。同时支持字符串和对象参数；\nstring: (任一) ip+port 格式，如 127.0.0.1:9099；\nobject: (任一) { host, port }；\nhost: 字符串，支持 ip 和域名；\nport: 数字，最小值为0，最大值为65535；\nchannelOptions: (可选) proto channel options；\ncredentials: (可选) 证书链，使用makeCredentials()获取；\n返回值:\nvoid: 空。","client#client()":"功能说明:\n获取'path.to.serviceName'对应的 proto 定义的 service 客户端实例，走proxy, 会缓存，可以查看 Client Proxy 获取更多使用API。\n参数说明:\nname: (必选) proto 定义的 service，包路径 + service name；\nhost: (可选) 字符串，支持 ip 和域名；\nport: (可选) 数字，最小值为0，最大值为65535；\ntimeout: (可选) 数字，单位是毫秒，rpc 调用控制超时时间；\ncredentials: (可选) 证书链，使用makeCredentials()获取；\nchannelOptions: (可选) proto channel options；\n返回值:\nvoid: 空。","clientwithoutcache#clientWithoutCache()":"功能说明:\n获取'path.to.serviceName'对应的 proto 定义的 service 客户端实例，走proxy, 不缓存，可以查看 Client Proxy 获取更多使用API。\n参数说明:\nname: (必选) proto 定义的 service，包路径 + service name；\nhost: (可选) 字符串，支持 ip 和域名；\nport: (可选) 数字，最小值为0，最大值为65535；\ntimeout: (可选) 数字，单位是毫秒，rpc 调用控制超时时间；\ncredentials: (可选) 证书链，使用makeCredentials()获取；\nchannelOptions: (可选) proto channel options；\n返回值:\nvoid: 空。","realclient#realClient()":"功能说明:\n获取'path.to.serviceName'对应的 proto 定义的 service 客户端实例，不走proxy, 不缓存，返回不经过处理的 client 实例。\n参数说明:\nname: (必选) proto 定义的 service，包路径 + service name；\nhost: (可选) 字符串，支持 ip 和域名；\nport: (可选) 数字，最小值为0，最大值为65535；\ntimeout: (可选) 数字，单位是毫秒，rpc 调用控制超时时间；\ncredentials: (可选) 证书链，使用makeCredentials()获取；\nchannelOptions: (可选) proto channel options；\n返回值:\nvoid: 空。","makecredentials#makeCredentials()":"功能说明:\n制作可供客户端使用的证书。\n参数说明:\nrootCerts: (可选) Buffer, 一般为 ca 文件；\nprivateKey: (可选) Buffer, 一般为 key 文件；\ncertChain: (可选) Buffer, 一般为 crt 文件；\nverifyOptions: (可选)，{ checkServerIdentity }；\ncheckServerIdentity: callback函数, (hostname, cert) => { }；\n返回值:存在两种情况:\n如果有完整的参数，则返回:grpc.credentials.createSsl()；\n如果没有参数，则返回: grpc.credentials.createInsecure()；","makemetadata#makeMetadata()":"功能说明:\n创建供客户端使用的的 metadata 实例。\n参数说明:\nobject: (必选)，对象:\n[key]: 字符串，key 值；\n[value]: 字符串，或字符串数组，非字符串场合会在内部转 Buffer;\n返回值:\nMetadata 实例。","initserver#initServer()":"功能说明:\n创建 gRPC server 实例，并提供一些列 server API。更多相关 API 请查看 Server\n参数说明:\nchannelOptions: (可选) proto channel options；\n返回值:\n返回 Server 实例，可以查看 Server 获取更多 API。","callbackify#callbackify()":"功能说明:\n主要是搭配server.addService()使用，将async func转换为callback func，使得server rpc与target绑定。\n参数说明:\ntarget: (必选) 包含rpc func本身的对象或者实例。\nobject: (可选) 对象:\nexclude: (可选) 字符串数组，排除target中不需要参与service rpc绑定的方法；\ninherit: (可选) 如果 target 通过继承的方式获得的func也要参与绑定，则需要把继承的对象也要传参；\n返回值:\ncallbackify methods对象，可以给 server.addService() 使用，不会报错。","service#service()":"功能说明:\n获取proto中的service定义。\n参数说明:\nname: (必选) 指 proto 文件路由，具体是到 service 的位置;\n返回值:\nproto 中的 service 定义。","type#type()":"功能说明:\n获取proto中的type定义;\n能力上包含了service();\n参数说明:\nname: (必选) 指 proto 文件路由，包名到service，或到model，或到message;\n返回值:\nproto 中的 type 定义。","message#message()":"功能说明:\n获取proto中的message定义;\n参数说明:\nname: (必选) 指 proto 文件的路由，具体是指路由 message 的链条名。\n返回值:\nproto 中的 message 定义。"}},"/zh-CN/guide/config":{"title":"Config","data":{"":"gRPCity关于proto有两个非常重要的配置，分别是loadOptions和channelOptions。\n其中，init()两个都使用到，而initClients()和initServer()只使用了channelOptions。\nloadOptions: 对应的是proto文件加载时的规则配置；\nchannelOptions: 对应的是服务端与客户端通信直接的规则配置；","loadoptions#loadOptions":"loadOptions 包含的字段，详情如下:\n字段名称\t有效值\t描述\tkeepCase\ttrue 或 false\t保留字段名。默认情况下将它们更改为驼峰命名法。\tlongs\tString 或 Number\t用于表示 long 值的类型。默认为 Long 对象类型。\tenums\tString\t用于表示 enum 值的类型。默认为数值类型。\tbytes\tArray 或 String\t用于表示 bytes 值的类型。默认为 Buffer。\tdefaults\ttrue 或 false\t在输出对象上设置默认值。默认为 false。\tarrays\ttrue 或 false\t即使 defaults 为 false，对于缺失的数组值设置空数组。默认为 false。\tobjects\ttrue 或 false\t即使 defaults 为 false，对于缺失的对象值设置空对象。默认为 false。\toneofs\ttrue 或 false\t对于当前字段，将虚拟的 oneof 属性设置为字段名。默认为 false。\tjson\ttrue 或 false\t在 float 字段中将 Infinity 和 NaN 表示为字符串，并自动解码 google.protobuf.Any 值。默认为 false。\tincludeDirs\t字符串数组\t导入的 .proto 文件的搜索路径列表。\t\ngRPCity的默认loadOptions为:","channeloptions#channelOptions":"channelOptions 支持度保持跟grpc-js官方一致，我们可以从 这里 看到所有的channel配置项。\n我们可以从 这里 看到目前支持的配置项。gRPCity的默认channelOptions为:"}},"/zh-CN/guide":{"title":"用户指南","data":{"":"请选择下面的指南，进行更深入的了解和学习使用:"}},"/zh-CN/apis/server":{"title":"Server API","data":{"":"通过调用loader.initServer()获取server实例，实例挂着一系列 API，方便我们去支持 gRPC Server 开发。","addservice#addService()":"功能说明:\n将proto service rpc定义与具体的执行实现进行绑定。\n参数说明:\nservice: (必填) 需要通过loader.service(name)来获取 proto 里指定的service；\nimplementation: (必填) 携带 service rpc 定义好的方法的对象或者类，需要通过loader.callbackify()来async化，并支持中间件；\n返回值:\nvoid: 空。","removeservice#removeService()":"功能说明:\n对已经绑定的service进行解绑。\n参数说明:\nservice: (必填) 需要通过loader.service(name)来获取 proto 里指定的service；\n返回值:\nvoid: 空。","makeservercredentials#makeServerCredentials()":"功能说明:\n1\n参数说明:\nrootCerts: (可选) Buffer, 一般为 ca 文件；\nkeyCertPairs: 证书对，key和crt，必须数组；\nprivate_key: (可选) Buffer, 一般为 key 文件；\ncert_chain: (可选) Buffer, 一般为 crt 文件；\ncheckClientCertificate: (可选) 是否检查客户端证书；\n返回值:存在两种情况:\n如果有完整的参数，则返回:grpc.ServerCredentials.createSsl()；\n如果没有参数，则返回: grpc.ServerCredentials.createInsecure()；","addmiddleware#addMiddleware()":"功能说明:\n添加一个处理 rpc 前后逻辑的中间件。\n参数说明:\nfn: (必选) 中间件函数，一般为async (ctx, next) => { await next() }\n返回值:\nvoid: 空。","addmiddlewares#addMiddlewares()":"功能说明:\n添加多个处理 rpc 前后逻辑的中间件。\n参数说明:\nfns: (必选) 中间件函数数组，一般为[ async (ctx, next) => { await next() } ]\n返回值:\nvoid: 空。","listen#listen()":"功能说明:\n监听地址与端口，启动 gRPC 服务。\n参数说明:\naddr: (必选) 服务启动需要监听的地址和端口，支持类型如下，任选一个:\nstring: ip+port 格式，如 127.0.0.1:9099；\nobject: { host, port }；\nhost: 字符串，支持 ip 和域名；\nport: 数字，最小值为0，最大值为65535；\ncredentials: (可选) 使用makeServerCredentials来生成，并给listen调用；\n返回值:\nvoid: 空。","shutdown#shutdown()":"功能说明:\ngRPC 服务优雅退出。\n参数说明:\nvoid: 空。\n返回值:\nvoid: 空。","forceshutdown#forceShutdown()":"功能说明:\ngRPC 服务强制退出。\n参数说明:\nvoid: 空。\n返回值:\nvoid: 空。"}},"/zh-CN/guide/client":{"title":"Client","data":{"":"Client是gRPCity的核心功能之一，主要是提供获取 service，并进行 rpc 调用。","初始化#初始化":"初始化有两种方式，init()和initClients()，这两个方法有场景上的使用注意事项:\ninit(): 支持传入services和channelOptions参数，就自动在内部创建好client，将service与rpc进行绑定，但是不支持证书;\ninitClients(): 支持传入services、channelOptions和credentials参数，支持证书;\ninit()更多适合希望在一个统一的位置，就做好了客户端的初始化，其他位置的调用就不用那么麻烦了，\n而initClients()适合更准精细化控制，例如有些服务端有证书有些没有，有些位置的只需要较少的调用等等场景。两者是可以共存的，但是使用initClients()之前，需要先执行init().channelOptions参数说明请看 Config 指南，示例:\n或者","获取实例#获取实例":"这里获取实例的方式相对简单，直接调用client()即可，注意需要传入完整的service name，包括了包名。\n注意: client()会缓存客户端，保证每次获取相同的客户端的时候，不会重复创建，减少内存消耗。","调用-rpc#调用 rpc":"调用 rpc 有两种方法，分别是async和callback，习惯上，我们更多是使用async语法，支持了promise。","async#async":"这里直接使用async/await语法。\nrpcMethod（请求方法）: 这是一个执行请求的方法。请求方法取决于定义的 gRPC 服务的.proto文件中的rpc，有4种形式，分别是点对点、流对点、点对流，流对流；\nrequest（请求参数）: 这是一个包含请求数据的对象。请求对象的结构取决于定义的 gRPC 服务的.proto文件中的消息类型；\nmetadata（元数据）: 这是一个可选参数，用于传递与请求相关的元数据。元数据是以键值对的形式表示的信息，可以包含用于身份验证、授权、跟踪或其他目的的数据；\noptions（选项）: 这是一个可选参数，用于设置特定的调用选项。它是一个包含一组键值对的对象，可用于配置调用的行为。一些可用的选项包括超时时间、重试策略等。如果不传该参数，默认会设置10秒超时，可以通过传入deadline的方式修改超时时间；\n这里展示的是点对点的例子:\nclient发起请求后，收到的结果包含了三个值，分别是status、metadata和response。\nstatus: 服务端处理执行后的状态；\nmetadata: 服务端返回的 metadata 信息；\nresponse: 服务端处理完成后响应的结果；\n我们打印一下返回的结果:","callback#callback":"callback的调用需要多加一个原型链，如.call.。\ncallback的方法提供了stream的事件方式的处理能力。更多关于stream的使用，请查看 Stream 和 Stream v2 这两篇指南。"}},"/zh-CN/guide/error":{"title":"Error","data":{"":"错误处理是保证服务正常运行的重要工作。gRPCity 也提供方便的错误处理方式。一般情况下，建议使用try/catch进行错误捕捉，采用throw进行错误暴露。","客户端发现错误#客户端发现错误":"客户端调用服务端，如果服务端报错，则会返回ERROR对象，对象包含下面4个字段:\nname: 值为GrpcClientError, 可以用来判断是否为客户端 rpc 的错误；\ncode: gRPC Status Code；\nmessage: gRPC Server emit message details;\nstack: file error trace stack;\nERROR对象完全展开后如下所示:","服务端触发错误#服务端触发错误":"下面展示如果客户端发送x-throw-error元信息，服务端执行sayHello()检查该元信息后主动触发报错的例子。\n服务端主动触发报错后，客户端捕捉到的错误报错，如上面客户端发现错误展示的例子一样。"}},"/zh-CN/guide/loader":{"title":"Loader","data":{"":"我们使用 Proto Loader 的时候，只需要在创建实例的时候，传入参数即可。\n为什么传参是location和files？\nlocation是指 proto 文件目录，包含 service 引用的 proto，如model.proto、empty.proto等等这些被独立引用的文件。\nfiles是指具体的service.proto文件，告诉底层 service 的定义来自这些文件，是具体的服务体现。\n**带来的好处: **\nservice 加载非常清晰，知道是哪些 service 会被使用\nproto 的目录结构，可以自定义，不影响加载","目录获取#目录获取":"ESM 模块的代码文件目录获取如下:\n如果是 CommonJS 模块的代码只 __dirname 是全局的，只需要在需要用到的地方直接使用即可。","单个目录加载#单个目录加载":"大多数情况下，我们只需要加载一次proto目录，并指定多个service，如下所示:","多个目录加载#多个目录加载":"有时候，我们需要跨业务进行服务调用，这个时候就会出现多个proto目录都需要加载的情况，我们的gRPCity已经做好了这块的多proto目录的加载支持了。如下所示:","初始化-init#初始化 init()":"为什么 loader 还需要 init ？init 是真正把proto加载的执行。同时也是自定义参数和环境的配置位置，功能更加独立，可以放到服务框架流程中的第一步，只需要执行一次。","选项说明#选项说明":"options 的参数说明，包含如下参数:\nservices: （可选）跟 initClient() 里的参数一样，如果有这个参数，则可以跳过initClient，直接完成client的初始化。同时支持字符串和对象参数；\nstring: ip+port 格式，如 127.0.0.1:9099；\nobject: { host, port }；\nhost: 字符串，支持 ip 和域名；\nport: 数字，最小值为0，最大值为65535；\nisDev: （可选）布尔值，是否为开发模式；\npackagePrefix: （可选）字符串，service name 包前缀，如: dev, stage等等；\nloadOptions: （可选）proto load options；\nchannelOptions: （可选）proto channel options；\nappName: （可选）字符串，当前应用的应用名，用来标记；\n其中loadOptions和channelOptions更多说明请看这一篇: Config","示例#示例":"注意使用了packagePrefix之后，服务端和客户端都要一致。test 环境，配置如下:\nstage 环境，配置如下:\nproduction 环境，直接忽略掉一些配置项即可，配置如下:"}},"/zh-CN/guide/credentials":{"title":"Credentials","data":{"":"gRPC 建立在HTTP/2协议之上，对 TLS 提供了很好的支持。\n当不需要证书认证时，gRPCity默认是跳过了对服务器证书的验证。\n没有启用证书的 gRPC 服务和客户端进行的是明文通信，信息面临被任何第三方监听的风险。\n为了保证 gRPC 通信不被第三方监听、篡改或伪造，可以对服务器启动 TLS 加密特性。注意: 启动 TSL 后会对 CPU 的资源消耗是会增加的，如果是你的业务场景是高 QPS 的，不建议启动 TSL。","生成证书#生成证书":"创建自己的SSL证书。首先，我们需要为服务器和客户端创建自己的SSL证书。可以使用 OpenSSL 命令来生成自己的证书。我们使用bash脚本来完成证书的生成，先设置全局变量，如密码和证书有效期。","生成-ca-证书#生成 ca 证书":"","生成-server-证书#生成 server 证书":"","生成-client-证书#生成 client 证书":"最终我们获得如下的证书目录:","服务端配置#服务端配置":"我们开始进行服务端证书配置的工作。使用server.makeServerCredentials() 进行证书加载。server.makeServerCredentials(rootCerts, keyCertPairs, checkClientCertificate) 的参数说明如下:\nrootCerts: 跟证书，一般为 ca 证书；\nkeyCertPairs: 证书对，key和crt，必须数组；\ncheckClientCertificate: 是否检查客户端证书；\n示例:\n注意: 使用了证书后，不能使用 ip 来启动服务，可以使用localhost或域名。","客户端配置#客户端配置":"我们开始进行服务端证书配置的工作。使用loader.makeCredentials() 进行证书加载。\n获得credentials后，有两种加载方式，如下所示:","initclients-时加载#initClients() 时加载":"","client-时加载#client() 时加载":"注意:\ninitClients() 适合所有服务端都是使用同一个证书的场景\nclient() 适合只有个别的服务端有证书的场景，或不同服务端使用了不同的证书的场景"}},"/zh-CN/guide/metadata":{"title":"MetaData","data":{"":"MetaData 功能在 gRPC 里是非常重要。有些场景，我们需要像http header一样的能力，如链路追踪，调用来源等等场景，这个时候 Metadata 就是满足这些场景的功能。","客户端发送#客户端发送":"客户端发送metadata，需要调用loader.makeMetadata()，使用方式如下:\n我们打印metadata, 结果如下:\n注意，metadata会有一些默认情况，如下:gRPCity Client 默认发送以下的 metadata:\nx-client-hostname: 值为操作系统的hostname;\nx-client-app-name: 值为loader初始化时使用到的 appName;\ngRPCity Server 默认发送以下的 metadata:\ncontent-type: 值一般为application/grpc+proto;\nuser-agent: 值一般为grpc-node-js/1.9.7;\ndate: 值一般为Wed, 01 Nov 2023 03:31:06 GMT;","服务端接收#服务端接收":"服务端接收metadata的位置在 call.metadata 里，如果要使用需要先clone()出来，然后根据key去get(key)值。\n输出结果如下:","服务端发送#服务端发送":"有时候，我们也需要服务端把metadata信息发送返回给客户端的情况，方法如下:\n服务端发送metadata，客户端是可以接收到的。"}},"/zh-CN/guide/middleware":{"title":"Middleware","data":{"":"中间件是 gRPCity 提供 server 能力中的一个重要功能，它让我们能够在执行 rpc 处理之前和之后执行中间件代码。像统一调用日志打印，监控指标采集，鉴权，修改传参，修改结果和延时等业务场景中，中间件发挥非常便利的作用，使得我们处理业务能够提升开发效率。","原理#原理":"gRPCity的中间件实现是基于koa-compose库，它提供了洋葱模型的工作机制，方便我们去执行中间件。假如我们有 a、b、c 这三个中间件，中间件执行的顺序是a → b → c，如下所示:","用法#用法":"gRPCity server 提供了两个方法去支持中间件，分别是server.addMiddleware(fn)和server.addMiddlewares(fns)。两个方法区别就是一个只能传入一个中间件，另外一个可以传入多个中间件，如:\n添加中间件的使用位置在initServer()之后，在listen()之前。","编写中间件#编写中间件":"在这里我们将演示可以编写 rpc 调用日志打印的中间件。中间件方法支持两个参数，分别是ctx和next，详情如下:\nctx: object类型，中间件上下文;\npath: rpc 路由路径；\nrequest: rpc 请求参数；\nmetadata: 来自客户端的metadata；\nresponse rpc method 返回结果，需要 rpc method 执行后才会有的；\nnext: function类型，执行下一个中间件或者方法本体;\n添加中间件\n至此，我们完成了中间件的编写与使用。"}},"/zh-CN/guide/proto":{"title":"Proto","data":{"":"有时候，我们需要得到处理 proto 内容的能力，gRPCity库就提供了这样的能力，同时这些能力中在内部也会被调用。\n例如: addService(serviceName, implementation)，就需要获取 proto 文件里定义的 service name。好处是多做了一层校验，保证服务的正确性。","加载-proto#加载 proto":"假如我们的 proto 路径是 protos/test/helloworld/, proto 的内容如下\n我们需要先完成 proto 的加载。","servicename#service(name)":"name参数，指 proto 文件路由，具体是到 service 的位置。","typename#type(name)":"name参数指 proto 文件的路由，包名到service，或到model，或到message。type()的能力包含了service()。","messagename#message(name)":"name参数是指 proto 文件的路由，具体是指路由 message 的链条名。","编码和解码#编码和解码":"","注意#注意":"我们一般只需要关心 service() 和 message() 的用法就可以了，type()对外使用的情况很少。"}},"/zh-CN/guide/status":{"title":"Status","data":{"":"gRPCity库提供了非常便捷获取status的能力。一般情况下会很少使用到，这里就简单提及。","获取-status#获取 Status":"客户端获取服务端返回的status的方式，非常简单，如下所示。","status-code#Status Code":"默认的 Status Code 详细情况如下表所示:\nCode\tNumber\tDescription\tOK\t0\t非错误；表示成功返回。\tCANCELLED\t1\t操作被取消，通常是由调用方取消的。\tUNKNOWN\t2\t未知错误。例如，当从另一个地址空间接收到的“Status”值属于此地址空间中未知的错误空间时，可能会返回此错误。还可能将未返回足够错误信息的 API 引发的错误转换为此错误。\tINVALID_ARGUMENT\t3\t客户端指定了无效的参数。请注意，这与“FAILED_PRECONDITION”不同。“INVALID_ARGUMENT”表示无论系统状态如何，参数都存在问题（例如，格式错误的文件名）。\tDEADLINE_EXCEEDED\t4\t截止日期已过，操作无法完成。对于会改变系统状态的操作，即使操作已成功完成，也可能返回此错误。例如，来自服务器的成功响应可能已经被延迟很久。\tNOT_FOUND\t5\t未找到某些请求的实体（例如，文件或目录）。服务器开发者请注意: 如果请求被拒绝适用于整个用户类别，例如逐步特性发布或未记录的白名单，则可以使用“NOT_FOUND”。如果请求被拒绝适用于用户类别中的某些用户，例如基于用户的访问控制，则必须使用“PERMISSION_DENIED”。\tALREADY_EXISTS\t6\t客户端尝试创建的实体（例如，文件或目录）已经存在。\tPERMISSION_DENIED\t7\t调用方没有权限执行指定的操作。“PERMISSION_DENIED”不得用于由于耗尽某些资源而导致的拒绝（对于这些错误，请改用“RESOURCE_EXHAUSTED”）。如果无法识别调用方，请勿使用“PERMISSION_DENIED”（对于这些错误，请改用“UNAUTHENTICATED”）。此错误代码不意味着请求有效，请求的实体存在或满足其他前提条件。\tRESOURCE_EXHAUSTED\t8\t某些资源已经用尽，例如每用户配额，或者整个文件系统的空间已满。\tFAILED_PRECONDITION\t9\t操作被拒绝，因为系统处于操作所需的状态之外。例如，要删除的目录非空，rmdir 操作应用于非目录等。服务实现者可以使用以下准则来在“FAILED_PRECONDITION”、“ABORTED”和“UNAVAILABLE”之间进行选择: (a) 如果客户端可以重试失败的调用，请使用“UNAVAILABLE”。(b) 如果客户端应该在更高级别重试，请使用“ABORTED”（例如，当客户端指定的测试并设置失败时，表示客户端应重新启动读取-修改-写入序列）。(c) 如果客户端在系统状态被明确修复之前不应重试，请使用“FAILED_PRECONDITION”。例如，如果由于目录非空而导致“rmdir”失败，则应返回“FAILED_PRECONDITION”，因为除非从目录中删除文件，否则客户端不应重试。\tABORTED\t10\t操作被中止，通常是由于并发问题，例如序列器检查失败或事务中止。请参考上面的准则，以决定使用“FAILED_PRECONDITION”、“ABORTED”和“UNAVAILABLE”。\tOUT_OF_RANGE\t11\t操作尝试超出有效范围。例如，寻找或读取超出文件末尾的位置。与“INVALID_ARGUMENT”不同，此错误指示的问题在系统状态改变时可能会修复。例如，如果一个32位文件系统被要求读取不在范围 [0,2^32-1] 内的偏移量，它将生成“INVALID_ARGUMENT”，但如果被要求从当前文件大小之后的偏移量处读取，它将生成“OUT_OF_RANGE”。“续: FAILED_PRECONDITION\"和\"OUT_OF_RANGE\"之间存在一定的重叠。我们建议在适用时使用\"OUT_OF_RANGE\"（更具体的错误），以便迭代通过空间的调用者可以轻松查找\"OUT_OF_RANGE\"错误以检测完成的情况。\tUNIMPLEMENTED\t12\t该操作未实现或在此服务中不受支持/启用。\tINTERNAL\t13\t内部错误。这意味着底层系统预期的某些不变条件已被破坏。该错误代码保留用于严重错误。\tUNAVAILABLE\t14\t服务当前不可用。这很可能是一种暂时的条件，可以通过使用指数退避进行重试来纠正。请注意，并非总是可以安全地重试非幂等操作。\tDATA_LOSS\t15\t无法恢复的数据丢失或损坏。\tUNAUTHENTICATED\t16\t请求没有有效的操作认证凭据。","status-case#Status Case":"除了OK外，我们也需要了解其他Code产生的可能原因，如下表所示:\nCase\tCode\t产生的位置在 Client 或 Server\t客户端应用程序取消了请求\tCANCELLED\tBoth\t截止时间到期之前服务器未返回状态\tDEADLINE_EXCEEDED\tBoth\t服务器上找不到方法\tUNIMPLEMENTED\tServer\t服务器正在关闭\tUNAVAILABLE\tServer\t服务器端应用程序抛出异常（或执行了除返回状态代码以外的其他操作，终止 RPC）\tUNKNOWN\tServer\t截止时间到期之前未收到响应。这可能发生在客户端无法将请求发送到服务器或服务器未能及时响应时。\tDEADLINE_EXCEEDED\tBoth\t连接中断前传输了一些数据（例如，请求元数据写入 TCP 连接）\tUNAVAILABLE\tClient\t无法解压缩，但支持压缩算法（客户端 -> 服务器）\tINTERNAL\tServer\t无法解压缩，但支持压缩算法（服务器 -> 客户端）\tINTERNAL\tClient\t客户端使用的压缩机制在服务器上不受支持\tUNIMPLEMENTED\tServer\t服务器暂时资源不足（例如，达到了流量控制资源限制）\tRESOURCE_EXHAUSTED\tServer\t客户端没有足够的内存来保存服务器的响应\tRESOURCE_EXHAUSTED\tClient\t流量控制协议违规\tINTERNAL\tBoth\t解析返回的状态时出错\tUNKNOWN\tClient\t错误的身份验证元数据（凭据无法获取元数据，通道和调用上设置的不兼容凭据，: authority 元数据中设置的无效主机等）\tUNAUTHENTICATED\tBoth\t请求基数违规（方法要求恰好一个请求，但客户端发送了其他数量的请求）\tUNIMPLEMENTED\tServer\t响应基数违规（方法要求恰好一个响应，但服务器发送了其他数量的响应）\tUNIMPLEMENTED\tClient\t解析响应协议时出错\tINTERNAL\tClient\t解析请求协议时出错\tINTERNAL\tServer\t发送或接收的消息大于配置的限制\tRESOURCE_EXHAUSTED\tBoth\t保持活动监视器超时\tUNAVAILABLE\tBoth"}},"/zh-CN/guide/stream":{"title":"Stream","data":{"":"gRPCity 库提供了完整的 Stream 处理能力，流式 rpc 可以满足文件上传，事件机制，任务监听，指标回播等业务场景。\n目前流式 rpc 有三种情况，以client - server模式举例，分别是client stream - server、client - server stream 和 client stream - server stream。这里展示的使用callback和事件机制来完成流处理工作。使用的是client的proxy的call里的方法。如果需要获取async stream的用法，可以查看 Stream v2 指南。","前置工作#前置工作":"我们的 proto 文件里的 service 的rpc，需要标记清楚 使用了stream，如下所示:\nClientStreamHello: 表示只有客户端使用了 Stream;\nServerStreamHello: 表示只有服务端使用了 Stream;\nMutualStreamHello: 表示客户端和服务端都是使用了 Stream;\n编写 loader.js，完成 proto 加载。","服务端#服务端":"完成Stream类的编写，提供了三种流式的服务端执行函数。分别是clientStreamHello(),serverStreamHello(),mutualStreamHello()。\n继续完成服务初始化和启动。","客户端#客户端":"客户端使用Stream调用服务端，需要使用.call.里的函数才可以。示例如下:","联调#联调":"client stream - server: 我们只执行客户端的clientStreamHello()，执行结果如下:服务端:\n客户端:\nclient - server stream: 我们只执行客户端的serverStreamHello，执行结果如下:服务端:\n客户端:\nclient stream - server stream: 我们只执行客户端的mutualStreamHello，执行结果如下:服务端:\n客户端:"}},"/zh-CN/guide/stream-v2":{"title":"Stream v2","data":{"":"在0.9版本之后，gRPCity提供了client调用stream rpc的全部promisify的能力，这意味着我们能使用async/await的语法进行stream处理。下面我们将会展示如何使用Stream v2的能力。在这里也建议先看一遍 Stream，该文会有一些相似的地方在本文出现。注意: 本篇的服务端延用了 Stream 里的服务端。","定义-proto#定义 proto":"该 proto 定义了三个 rpc，正好对应了客户端与服务端的三种流对接方式，分别是流对点、点对流和流对流。","加载-proto#加载 proto":"","客户端#客户端":"客户端的一些前期工作，如加载 proto，初始化客户端，创建新的 metadata.","流对点#流对点":"流对点，指client stream request -> server response。我们继续在start方法里流对点的流程:\n运行结果如下，我们看到writeEnd()返回了这次调用服务端的返回结果{ status, metadata, response }，同时也把stream message发送到了服务端。","点对流#点对流":"点对流，指client request -> server stream response。我们继续在start方法里点对流的流程:\n运行结果如下:我们看到readAll()返回了一个asyncIterator，需要我们使用for await获取服务端返回的逐条stream message结果。\n而readEnd()返回了{ status, metadata }，同时也看到服务端的打印记录，也接收到了客户端发送的message。","流对流#流对流":"流对流，指client stream request -> server stream response。我们继续在start方法里流对流的流程。我们先调用writeAll()发送3条消息，然后再调用write()发送1条消息，最后调用readAll()获取服务端返回的结果。\n运行结果如下，我们看到我们是先客户端发送消息完给服务端后，调用readAll()，获取asyncIterator，需要我们使用for await获取服务端返回的逐条stream message结果。\n最后，调用readEnd()获取服务端结束流信息返回的{ status, metadata }。"}},"/zh-CN":{"title":"gRPCity","data":{"":"gPRCity: 一套简单、易用和高级的基于 Node.js 的 gRPC 微服务库。\n名字来源于: gRPC + City = gRPCity，寄托了作者希望这个库能支撑了业务城市的建设，以技术底座的视角，让大家聚焦业务，更好地支撑交付。在这里给大家推荐一款游戏，叫《城市: 天际线2》，这是一款城市模拟类游戏，让玩家切身体会从创造到维持一座真正的城市的兴奋和艰辛。","仓库#仓库":"GitHub: https://github.com/chakhsu/grpcity\nnpm: https://www.npmjs.com/package/grpcity","目标#目标":"致力于提供完整的基于 Node.js 的、基于 gRPC 的微服务开发体验。基于更丰富的特性，给 Node.js 社区和开发者提供多一种微服务库的选择。做好两个底座，微服务库技术底座和业务支持底座。","原则#原则":"聚焦: 只做好 gRPC 微服务库，不做大而全的框架；\n简单: 提供简单和清晰的 API，轻松看懂，快速上手；\n易用: 尽可能地简化复杂的概念，提供清晰的、容易的代码；\n稳定: 可测试性高，覆盖率高，有线上实践安全可靠；\n共建: 充分利用 Node.js 社区和生态；","特性#特性":"API: 通信协议以 gRPC 为基础，通过 Protobuf 进行定义；\nProtobuf: 只支持动态 pb 加载，简化了 pb 文件的加载流程；\nClient: 一次配置，随时随处调用，支持 multi-server 的调用；\nServer: 简化了初始化流程，三步完成服务端的启动，支持 multi-server 的启动；\nNo-Route: 无路由，rpc 与 method 天生绑定；\nMiddleware: 集成了跟 Koa 一样中间件机制，得到了 rpc 前后处理的能力；\nMetadata: 规范化了元信息的传递和获取；\nError: 提供了专有 Error 对象，保证异常捕捉后可以针对性处理；\nPromise: rpc 方法内部支持了 promisify，同时也保留了 callbackify ；\nConfig: 与官方配置对齐，支持 pb load 配置和 gRPC channel 配置；\nPattern: 单例模式，保证了实例对象的唯一性；\nTypescript: 支持，保证了 ts 和 js 的兼容性；\n...还有更多等你发现。"}},"/zh-CN/guide/server":{"title":"Server","data":{"":"Server是gRPCity的核心功能之一，提供了服务端生命周期的接管能力。通过一系列的接口函数，提供了从证书导入、服务绑定、中间件支持，服务启动和服务退出等，全周期的管理。","实例获取#实例获取":"channelOptions在 Config 指南 里有详细讲解。\n得到server实例后，实例会有一系列的接口来帮助我们开发服务。","服务绑定#服务绑定":"服务绑定需要两个参数，一个是service，另外一个是implementation。\nservice: (必填) 需要通过loader.service(name)来获取 proto 里指定的service；\nimplementation: (必填) 携带 service rpc 定义好的方法的对象或者类，需要通过loader.callbackify()来async化，并支持中间件；","添加中间件#添加中间件":"gRPCity Server 的特色功能，提供了implementation 前后处理的中间件能力，更多详情查看 Middleware 指南注意: 只有使用了loader.callbackify()绑定的service rpc 才支持中间件。","证书与启动#证书与启动":"服务启动 listen 支持两个参数，分别是addr和credentials:\naddr: (必选) 服务启动需要监听的地址和端口，支持类型如下，任选一个:\nstring: ip+port 格式，如 127.0.0.1:9099；\nobject: { host, port }；\nhost: 字符串，支持 ip 和域名；\nport: 数字，最小值为0，最大值为65535；\ncredentials: (可选) 使用makeServerCredentials来生成，并给listen调用；\n另外，可以阅读 Credentials 指南 来获得更多信息。","服务退出#服务退出":"shutdown() 需要使用async来保证异步执行完成，而forceShutdown不需要。"}},"/zh-CN/start":{"title":"Get Started","data":{"":"我们假设你已经入门了 gRPC、Node.js 和 JavaScript，有一个基础的认知。官方文档是最好的老师，关于基础 gPRC 入门推荐: link 。快速入门教程将会分成 3 篇，最终带你们完成一个完整的基于 gRPCity 的微服务服务端开发与客户端调用。入门教程对应的项目代码已经放到了GitHub: link 。"}},"/zh-CN/start/proto-loader":{"title":"Proto loader","data":{"":"官方提供了两种protobuf 文件加载方式，一种是直接加载 pb 文件，另外一种是工具编译后再通过依赖引用的方式。\n这两种方式的各有优劣，在这里 gRPCity 最终选择了仅支持第一种方式，就是直接加载 pb 文件。下面我们将会通过新建项目的方式进行快速入门，demo 项目仓库: link。","初始化与安装依赖#初始化与安装依赖":"创建 demo 项目并进入:\n初始化:\n安装依赖:\n注意: 我们需要在package.json里补上\"type\": \"module\",，激活 esm 模块。","项目目录#项目目录":"我们需要创建一系列的目录和文件，最终项目目录与文件结构如下:","定义-proto#定义 proto":"创建 proto 目录，创建service.proto文件:\n我们定义两个 service，分别是 Greeter 和 Hellor，同时把 message 拆分到 model 里。对service.proto输入如下内容:\n创建 model 目录，创建message.proto文件:\n对message.proto输入如下内容:","加载-pb--模块化#加载 pb & 模块化":"引入grpcity依赖，并创建实例，注意需要传入两个参数，分别是location和files，这两个参数分别表示 proto 文件的根目录和具体 proto 文件。\n至此，我们完成了 proto 文件的加载工作，并得到了loader.js。\n这样我们就可以随处引入该文件，并支持我们去开发客户端调用或者服务端启动。\n是不是非常简单？与官方的对比，本库去掉了大量的难以理解的定义，只需要将文件传入到对应的对象中即可完成文件加载。下面我们就开始后续的客户端或服务端的上手开发工作吧。"}},"/zh-CN/start/client":{"title":"Client Side","data":{"":"客户端的开发工作相对简单一些，在这里你能看到如何轻松实现调用两个不同的 gRPC 服务端。","项目目录#项目目录":"我们在原来的项目里提前创建好client.js。","初始化#初始化":"第一步: 导入loader.js模块，我们在后续的开发中使用到这个模块去完成rpc与服务端的方法进行绑定。\n第二步: 初始化客户端，需要传入服务端名称和地址","调用和启动#调用和启动":"我们接着在 start 方法里补充客户端调用服务端的逻辑，并打印调用结果。client发起请求后，收到的结果包含了三个值，分别是status、metadata和response。\nstatus: 服务端处理执行后的状态；\nmetadata: 客户端发送和服务端返回的 metadata 信息；\nresponse: 服务端处理完成后响应的结果；","联调#联调":"在上一篇服务端教程，我们已经启动好了两个 server，所以我们只需要直接执行 client 就可以完成联调。\n第一次执行结果如下:\n第二次执行结果如下:\n我们能看到两次结果都是正常返回，其中sayGreet中的count，在第二次执行后累加为2，符合预期，也说明这次客户端调用服务端的闭环完成了。快速入门使用的项目仓库: link。入门教程已完结了，是不是感觉非常简单和易用，欢迎回顾和进一步学习。"}},"/zh-CN/start/server":{"title":"Server Side","data":{"":"上一篇教程，我们得到了loader.js，一个已经帮我们完成了 proto 文件加载工作的模块，在这篇教程里，我们将会使用该模块完成服务端的开发。我们开始吧~我们将会提供两种写法给你，以满足不同的场景需要。","项目目录#项目目录":"我们在原来的项目里提前创建好server.js和server2.js，分别对应两种写法。","写法1-推荐#写法1 (推荐)":"第一步: 导入loader.js模块，我们在后续的开发中使用到这个模块去完成rpc与服务端的方法进行绑定。","定义类#定义类":"第二步: 定义Greeter类\n第三步: 继续用同样的方式定义Hellor类","绑定和启动#绑定和启动":"","写法2#写法2":"我们另外在server2.js上进行编码。第一步: 导入loader.js模块，我们在后续的开发中使用到这个模块去完成rpc与服务端的方法进行绑定。","定义对象#定义对象":"第二步: 定义Greeter对象\n第三步: 继续用同样的方式定义Hellor对象","绑定和启动-1#绑定和启动":"","联调#联调":"我们看到，不管是方法1还是方法2，都实现了将多个 service 注册到了同一个 server 里。\n这里为啥推荐方法1，是因为方法1的写法对模块化更友好，可以将类拆出来，独立成文件，实现流程与业务解耦，增加服务的扩展性。\n在方法2中，展示了两种rpc method 的支持，即支持promise style，也支持callback style。一般来说，我们更多使用promise style 的rpc method 写法。我们将会启动这两个 server，在后续 client side 教程中，我们将会同时调用这两个 server，将 gRPC 的调用闭环。详细的联调环节将会在 client side 教程中展示。\n启动后，我们的客户端就可以连上相应的地址就可以实现访问调用啦。下面我们就开始后续的客户端上手开发工作吧。"}}}